#!/bin/env perl

# https://perl.com/pub/2012/04/perlunicook-standard-preamble.html
use utf8;      # so literals and identifiers can be in UTF-8
use v5.12;     # or later to get "unicode_strings" feature
use strict;    # quote strings, declare variables
use warnings;  # on by default
use warnings  qw(FATAL utf8);    # fatalize encoding glitches
use open      qw(:std :utf8);    # undeclared streams in UTF-8
use charnames qw(:full :short);  # unneeded in v5.16

our $AUTHOR='zrajm <zrajm@zrajm.org>';
our $VERSION='0.8.16';                        # https://semver.org/
our $VERSION_DATE='26 December 2025';
our $CREATED_DATE='11 November 2025'; # never change this!
our $PROGRAM = (split '/', decode(__FILE__))[-1];
our $USAGE = <<"USAGE_END";
Usage: $PROGRAM [OPTION]... [--] [QUERY] [FIELD=VALUE]... [FILE]
Search or update/add records in a ZDB text file database.

  -s, --case-sensitive    Do not ignore case when searching
      --color[=WHEN]      When to highlight matches (default 'auto')
                          WHEN is 'auto', 'always' or 'never'
  -c, --color             Always highlight matches (means --color=always)
  -C, --no-color          Never highlight matches (means --color=never)
  -e, --match=QUERY       Specify QUERY explicitly (usually omitted)
  -h, --help              Show this help and exit
      --help-query        Show QUERY syntax (it's very googlish)
  -i, --ignore-case       Ignore case when searching
  -M, --manual            Show zdb manual page (with 'man')
      --pager=CMD         Use CMD as pager (default 'pager')
      --paging[=WHEN]     When to use pager (default 'auto')
  -p, --paging            Always use pager (means --paging=always)
  -P, --no-paging         Never use pager (means --paging=never)
  -S, --smart-case        Ignore case if entire QUERY is lowercase (default)
      --test              Run built-in unit tests
  -v, --verbose           Show debugging output while running
      --version           Show version and exit

Show records matching QUERY, or if FIELD=VALUE(s) are given insert those into a
matching record (or add a new record if there is no QUERY).

NOTE: If QUERY begins with hyphen ('-'), it's read as an option. Avoid this by,
for example, adding a comma (',') to the start of QUERY (this doesn't change
its meaning), by putting end-of-options indicator ('--') before QUERY, or by
using the '-e' option.
USAGE_END
our $QUERY = <<"QUERY_END";
NOTE: QUERY will be taken for an option if starts with '-'. To avoid, prefix it
with a character that doesn't change the meaning of the query (e.g. comma ','),
or precede the QUERY argument with the option terminator ('--').

Special characters (in order of precedence)
-------------------------------------------
  \e[1m=\e[m   (equal)  match whole field
  \e[1m-\e[m   (minus)  logical NOT
  \e[1m␣\e[m   (space)  logical AND
  \e[1m,\e[m   (comma)  logical OR
  \e[1m(\e[m…\e[1m)\e[m (parens) grouping

EXAMPLES
========
* \e[1mname:\e[m = Find records with field called 'name'.
* \e[1m-name:\e[m = \e[1m-(name:)\e[m = Find records without field 'name'.
* \e[1mname:emma\e[m = \e[1m(name: && name:emma)\e[m = Find records where field 'name' exists
  and contains 'emma'.
* \e[1m-name:emma\e[m = \e[1m-(name: || name:emma)\e[m = Find records without field 'name', and
  records where it exists, but does not contain 'emma'.
* \e[1mname:-emma\e[m = \e[1m(name: && -name:emma)\e[m = Find records where field 'name' exists,
  but does not contain 'emma'.

* \e[1m(-name):emma\e[m = \e[1m(-name: && name:emma)\e[m = NONSENSE. Find records without field
  'name', but where field name contains 'emma'.
QUERY_END

my %opt;
my $pager_pid;
END {
    if ($? > 0) {
        kill('TERM', $pager_pid) if $pager_pid;
    } else {
        close STDOUT or die "Can't close standard output: $!\n";
    }
    { local $?; wait() }                       # wait for pager to exit
}

# Recutils:
# https://www.gnu.org/software/recutils/manual/recutils.html
#  * field name: '[a-zA-Z%][a-zA-Z0-9_]*'
#  * type name:  '[a-zA-Z][a-zA-Z0-9_]*'

###############################################################################
# Functions
{
    use Encode ();
    state sub OPT() { Encode::FB_CROAK | Encode::LEAVE_SRC }
    sub encode { eval { Encode::encode('UTF-8', shift // $_, OPT) } }
    sub decode { eval { Encode::decode('UTF-8', shift // $_, OPT) } }
}

sub version {
    my ($years)    = $CREATED_DATE =~ m#(\d{4})#;
    my ($end_year) = $VERSION_DATE =~ m#(\d{4})#;
    $years .= "-$end_year" unless $years eq $end_year;
    return <<~"VERSION_END";
    $PROGRAM $VERSION ($VERSION_DATE)
    Copyright (C) $years $AUTHOR
    License GPLv2: GNU GPL version 2 <https://gnu.org/licenses/gpl-2.0.html>.
    This is free software: you are free to change and redistribute it.
    VERSION_END
}

sub manpage {
    # Run 'pod2man'.
    open(my $fh, '-|', qw/pod2man --utf8 --errors=die/,
        "--release=$PROGRAM $VERSION", __FILE__)
        or die "Can't exec 'pod2man': $!\n";
    my @manpage = <$fh>;
    close($fh) or die (
        "Command 'pod2man' failed: " .
        ($! || "Exit status " . ($? >> 8)) . "\n");

    # Output result to 'man'.
    my $pid = open(STDOUT, '|-', qw/man -l -/)
        or die "Can't exec 'man': $!\n";
    print @manpage;
    exit 0;
}

###############################################################################

# my $record = record(<<~"END_RECORD");
#     country	Greenland
#     name	Anders Grönroot
#     END_RECORD
sub record {
    my ($str) = @_;
    my @record;
    while ($str =~ m#\G(\n*)(\w+)(\h+)(.*)(\n)#gc) {
        push(@record, { field => $2, value => $4, space => [$1, $3, $5] });
    }
    return \@record;
}

# Is invoked for every text string.
sub highlight {
    my ($str, @marks) = @_;

    # Normalize ranges into a flat list of marks
    # Each mark: [N, 'beg'|'end']
    my @mark = sort {
        $a->[0] <=> $b->[0] or $a->[1] cmp $b->[1];
    } map {
        my ($beg, $end) = @$_;
        (defined $beg and defined $end)   # FIXME: needed?
            ? ([$beg, 'beg'], [$end, 'end']) : ();
    } @marks;

    my ($lvl, $prev_mark, $out) = (0, 0, '');
    while (@mark) {
        my ($pos, $type) = @{ shift(@mark) };

        # Get text up to this mark.
        $out .= substr($str, $prev_mark, $pos - $prev_mark);
        $prev_mark = $pos;

        # Insert ANSI color code.
        $lvl += ($type eq 'beg') ? +1 : -1;
        $out .= ($lvl > 2 ? "\e[30;47m"  :     # white
                 $lvl > 1 ? "\e[30;106m" :     # bright teal
                 $lvl > 0 ? "\e[30;44m"  :     # blue
                 "\e[39;49m");                 # black background
    }
    $out .= substr($str, $prev_mark);
    # If color code is line wrapped, reinsert after newline.
    # FIXME: This will fail if it wraps across more than one newline.
    $out =~ s/((\e\[30;\d+m)[^\e\n]*\n)/$1$2/g;
    return $out;
}

###############################################################################

# FIXME: Be smarter. Don't load entire file into memory in constructor.
# Also, maybe don't hardcode record and field separators?
#
# NOTE: Final record contain only whitespace (no data).
{
    package ZDB;
    #my $ENTRY_SEPARATOR = qr/((?:\n|\A)\n+)(?!\h)/;
    my $FIELD_SEPARATOR = qr/(?<=\n(?!\s))/;
    my $ENTRY_REGEX = qr/((?:.+\R(?:\R+\h)?)+)/;
    sub new {
        my ($class, %opt) = @_;
        my $tempfile = $opt{write} && $opt{file} ? ".$opt{file}.tmp"  : '';
        my $lockfile = $opt{write} && $opt{file} ? _lock($opt{file})  : '';
        my $out      = $opt{write}               ? _open_w($tempfile) : '';
        my $in       =                             _open_r($opt{file});
        my $self = {
            file => $opt{file},
            lock => $lockfile,
            temp => $tempfile,
            out  => $out,
            in   => $in,
            rec  => [split($ENTRY_REGEX, do { local $/; <$in> })],
            num  => 0,
        };
        return bless($self, $class);
    }
    # Write a lockfile symlink with following data 'user@host.pid:epoch' and
    # erase the file when we go out of scope.
    sub _lock {
        my ($file) = @_;
        my ($lock, $time, $host, $user) = (".$file.lock", time(), do {
            open my $fh, '</etc/hostname'; <$fh> =~ /.*/; $&;
        }, (getpwuid($<) // ''));
        symlink("$user\@$host.$$:$time", $lock)
            or die "Cannot lock file '$file': Lock held by other process\n" . do {
                my ($user, $host, $pid, $time) = (readlink($lock) // '')
                    =~ /^([^@]*)@(.*)\.(\d*):(\d*)$/;
                my $info = join ', ', grep { $_ }
                    $user && "by user $user",
                    $host && "on host $host",
                    $pid  && "process $pid",
                    $time && "on " . localtime($time);
                $info && "    ($info)\n";
            };
        return $lock;
    }
    sub _open_r {
        my ($file) = @_;
        if (not $file) {
            die "Can't read standard input from terminal\n" if -t STDIN;
            return *STDIN;
        }
        open(my $fh, '<', $file)
            or die "Can't open file '$file' for reading: $!\n";
        return $fh;
    }
    sub _open_w {
        my ($file) = @_;
        return *STDOUT if not $file;
        open(my $fh, '>', $file)
            or die "Can't open file '$file' for writing: $!\n";
        return $fh;
    }
    # Final record will have only space, no data.
    sub read_record {
        my ($self) = @_;
        my ($spc, $txt) = splice(@{$self->{rec}}, 0, 2);
        return ()     if not defined($spc);
        return ($spc) if not defined($txt);

        my $FIELD_END = qr/(\n)(?!\s)/;
        my $FIELD_SEP = qr/\h+/;

        # FIXME: Handling of comments?
        my @record; #      1    2       [3]         [4]    5
        while ($txt =~ m/\G(\n*)(.*?)(?:($FIELD_SEP)(.*?))?($FIELD_END)/gcs) {
            # (field name, field value, pre-space, separator space, post-space)
            push(@record, [$2, $4 // '', $1, $3 // '', $5]);
        }
        return ($spc, @record);
    }
    sub write {
        my ($self, @data) = @_;
        print { $self->{out} } @data;
    }
    sub eof {
        my ($self) = @_;
        return !@{$self->{rec}};
    }
    sub DESTROY {
        my ($self) = @_;
        close($self->{in}) or die $self->{file}
            ? "Can't close input file '$self->{file}': $!\n"
            : "Can't close standard input: $!\n"
            if $self->{in};
        close($self->{out}) or die $self->{temp}
            ? "Can't close output file '$self->{temp}': $!\n"
            : "Can't close standard output: $!\n"
            if $self->{temp};
        rename $self->{temp}, $self->{file}
            or die "Can't rename file '$self->{temp}' to '$self->{file}': $!\n"
            if $self->{temp};
        unlink $self->{lock}
            or warn "Can't delete lock file '$self->{lock}': $!"
            if $self->{lock};
    }
}

###############################################################################

{
    package Query::Stack;
    my %paren = ( # define query parentheses
        and  => sub { [{ type => 'and',  field => 0, not => 0 }] },
        or   => sub { [{ type => 'or',   field => 0, not => 0 }] },
        atom => sub { [{ type => 'atom', field => 0, not => 0, quote => '' }] },
    );
    sub new {
        my ($class) = @_;
        return bless([[]], $class);
    }
    sub peek { return shift()->[-1]         }  # get last stack item
    sub last { return shift()->peek()->[-1] }  # last atom in last stack item
    # Set metadata options for last stack entry.
    sub set {
        my ($self, %opt) = @_;
        my $peek = $self->peek();
        %{$peek->[0]} = (%{$peek->[0]}, %opt);
        return $self;
    }
    # Strip any trailing empty atom/parenthesis in last stack item.
    sub trim {
        my ($self) = @_;
        my $last = $self->last();
        my $peek = $self->peek();
        pop @$peek                             # strip trailing term/paren
            if @$peek > 1                      #   if stack entry isn't empty
            and @$last == 1;                   #   and last term/paren is empty
        return $self;
    }
    sub push {
        my ($self, @thing) = @_;
        $self->trim();
        for (@thing) {
            $_ = $paren{$_}() if $paren{$_};   # expand 'and', 'or' etc.
            push(@{$self->[-1]}, $_);          # add to query
            push(@$self, $_)                   # push parenthesis to stack
                if $_->[0]{type} ne 'atom';
        }
        return $self;
    }
    sub pop {                                  # get last entry (and remove)
        my ($self, $done) = @_;
        $self->trim();
        my $popped = pop @$self;

        # If popped term contains parenthesis with a single term, remove
        # parenthesis (but keep the term inside). Also combine 'not' and
        # 'field' attributes from the parenthesis and the term inside.
        if (@$popped == 2) {
            $popped->[1][0]{field} ^= $popped->[0]{field};
            $popped->[1][0]{not}   ^= $popped->[0]{not};
            @$popped = @{$popped->[1]};
        }

        return $self if $done;                 # cleanup phase = abort
        #
        # FIXME: Currently stack is `[[QUERY], stack1, stack2, etc]`. If
        # `[QUERY]` is replaced by plain `QUERY`. We could just unshift the
        # wrapper into place `unshift(@$stack, $wrap)` (let the old query entry
        # become the first item on the stack, not having to do the `splice()`
        # business below).
        #
        # Make stack bottomless (to allow for unmatched ')' in query).
        if (@$self == 1) {                     # only QUERY left in stack
            $self->push('or', 'and');          #   add or(and(...)) parentheses
            $self->push($self->[0][0]);        #   and put QUERY inside that
            shift(@{$self->[0]});
        }
        return $self;
    }
}
{
    package Query;
    my %lang = (
        dump  => { map { $_ => \&{"_${_}_dumper"}     } qw/atom and or/ },
        plain => { map { $_ => \&{"_${_}_matcher"}    } qw/atom and or/ },
        color => { map { $_ => \&{"_${_}_aggregator"} } qw/atom and or/ },
    );

    sub new {
        my ($class, $query_str, $opt) = @_;
        $opt->{lang} = $lang{$opt->{lang} // 'plain'};
        my $query = _compile(_normalize(_parse($query_str)), $opt)
            or die "Failed to parse query";
        return bless($query, $class);
    }

    sub debug {
        my ($x, $seen) = @_;
        use Carp;
        confess "Too many args\n" if @_ > 2;
        confess "2nd arg (if given) must be hashref, not '$seen'\n"
            if defined($seen) and ref($seen) ne 'HASH';
        return 'undef' if not defined($x);     # UNDEF
        use Scalar::Util qw(blessed reftype);
        local $_ = reftype $x;
        if (not defined $_) {                  # SCALAR
            use warnings FATAL => 'numeric';   #   for eval {}
            no warnings 'void';
            return eval { $x + 0; 1 } ? $x : "'$x'";
        }
        return "↻$_" if $seen->{$x}++;         # CYCLIC REFERENCE
        my $class = blessed($x);
        my $out =
            # Array where 1st element is with hash with property 'type'.
            /^ARRAY$/ && ref($x->[0]) eq 'HASH' && exists $x->[0]{type} ? (
                $x->[0]{type} eq 'atom' ? ( # type is 'atom'
                    ($x->[0]{not}   ? '-' : '') .
                    ($x->[0]{field} ? '=' : '') .
                    (@$x > 1 ? "'@{[ join('', @$x[1..$#$x]) ]}'" : '∅')
                ) : (                       # type is non-'atom'
                    ($x->[0]{not}   ? '-' : '') .
                    ($x->[0]{field} ? '=' : '') .
                    "$x->[0]{type}(" . join(', ', map debug($_, $seen), @$x[1..$#$x]) . ')'
                )) :
            /^ARRAY$/    ? '['  . join(', ', map debug($_, $seen), @$x) . ']' :
            /^HASH$/     ? '{ ' . join(', ', map {
                (/^[a-z_]\w*$/iu ? $_ : "'$_'")
                    . ":"
                    . debug($x->{$_}, $seen);
            } sort keys %$x). ' }' :
            /^CODE$/     ? 'sub {}' :
            /^GLOB$/     ? $$x :
            /^REGEXP$/   ? do { undef $class;
                                $x =~ /^\(\?\^(\w*):(.*)\)$/ ? "qr/$2/$1" : "qr/$x/";
                            } :
            /^VSTRING$/  ? 'v' . join('.', map { ord } $$x =~ /\X/gu) :
            /^(FORMAT|IO)$/ ? sub { undef $class;
                                  for (sort keys %main::) {
                                      my $v = $main::{$_};
                                      return "*$_\{$&\}"
                                          if !ref($v) && *$v{$&} && *$v{$&} == $x;
                                  }
                                  return "*$&*";
                              }->() :
            /^(LVALUE|REF|SCALAR)$/ ? debug($$x, $seen) :
            '???';
        return !defined($class) ? $out :
            $class eq "Query::Stack" ? $out :
            $class eq "Query"        ? $out :
            "bless($out, '$class')";
    }

    sub _parse {
        my ($query_str) = @_;
        my $stack = new Query::Stack()->push('or', 'and', 'atom');
        my %machine = (
            '(' => sub {
                my ($last) = @_;
                $stack->push('or')->set(
                    not   => $last->[0]{not},
                    field => $last->[0]{field},
                )->push('and', 'atom');
            },
            ')' => sub { $stack->pop()->pop()->push('atom') },
            ',' => sub { $stack->pop()->push('and', 'atom') },
            ' ' => sub { $stack->push('atom') },
            #':' => sub { my ($s) = @_ },                                  # FIXME
            '"' => sub { my ($last, $chr) = @_; $last->[0]{quote} = $chr },
            "'" => sub { my ($last, $chr) = @_; $last->[0]{quote} = $chr },
            CHR => sub {
                my ($last, $chr) = @_;
                state %special = ('*' => '\w*', '_' => '\s+');
                return $last->[0]{quote} = '' if $chr eq $last->[0]{quote};
                # At the start of atom, and if not quoted.
                if (!$last->[0]{quote} and @$last == 1) {
                    # Flip 'not' or 'field' if '-' or '=' is seen.
                    return $last->[0]{not}   = !$last->[0]{not}   if $chr eq '-';
                    return $last->[0]{field} = !$last->[0]{field} if $chr eq '=';
                }
                push(@$last, $special{$chr} // quotemeta($chr));
            },
        );
        say "STACK: ", debug($stack) if $opt{verbose};
        for my $chr ($query_str =~ /\X/g) {  # grapheme clusters
            my $last = $stack->last();
            $machine{
                exists $machine{$chr} && !$last->[0]{quote} ? $chr : 'CHR'
            }($last, $chr);
            say("----------------------------------------\n",
                "READ : '$chr'\n",
                'STACK: ', debug($stack), "\n")
                if $opt{verbose};
        }
        $stack->pop(1) until @$stack == 1;
        return $stack->[0][0];
    }

    # Normalize '-' ('not') and '=' ('field') prefixes in query by pushing them
    # out into the leaf nodes, this converts query to Negation Normal Form.
    sub _normalize {
        my ($term, $not, $field) = @_;
        return $term unless ref $term;         # not parenthesis/atom
        state %flip = (and => 'or', or => 'and');
        my ($meta, @data) = @$term;
        $not   = ($not   // 0) ^ $meta->{not};
        $field = ($field // 0) ^ $meta->{field};
        return [$meta->{type} ne 'atom' ? {
            %$meta,
            type  => ($not ? $flip{$meta->{type}} : $meta->{type}),
            not   => 0,
            field => 0,
        } : {
            %$meta,
            not   => $not,
            field => $field,
        }, map { _normalize($_, $not, $field) } @data];
    }

    sub _prefix {
        my ($sep, $meta, @str) = @_;
        (!!$meta->{not} && '-') . (!!$meta->{field} && '=') . join($sep, @str);
    }
    sub _atom_dumper { my $x = _prefix('',                     @_); sub { $x } }
    sub  _and_dumper { my $x = _prefix(' ', shift, map $_->(), @_); sub { $x } }
    sub   _or_dumper { my $x = _prefix(',', shift, map $_->(), @_); sub { $x } }

    sub _regexify {
        my ($opt, @str) = @_;
        my $str = join('', @str);
        my $regex_flags = $opt->{case} ? '' : 'i';
        my ($beg, $end) = $opt->{field}
            ? ('^', '$')                       # whole field match
            : map {                            # word border for start/end
                /^\w$/u ? '\b' : '';           #   if last/first is letter
            } @str[0, -1];
        return qr/$beg(?$regex_flags:$str)$end/u;
    }

    # Create string matcher function. Initial call returns a matcher function
    # (a coderef). For initial call, first arg (a hashref) contains options.
    # With 'field' falsy matches word-by-word, with 'field' truthy matches
    # against whole strings. With 'not' true, search logic is negated.
    #
    # Invoke coderef with a set of strings to test if they match. If matching
    # returns true, otherwise false.
    #
    # FIXME: Consistent truthy/falsy values. Now return '' for false when
    # negated, and 0 when not negated.
    sub _atom_matcher {
        my ($meta, @str) = @_;
        my $regex = _regexify($meta, @str);
        return sub {
            for (@_) {
                return !$meta->{not} || () if m/$regex/;
            }
            return $meta->{not} || ();
        };
    }
    # Note: Doesn't do negation (done by _atom_matcher()).
    # First argument is completely ignored here.
    sub _and_matcher {
        my (undef, @func) = @_;
        return sub {
            for (@func) {
                return () unless $_->(@_);
            }
            return 1;
        };
    }
    # Note: Doesn't do negation (done by _atom_matcher()).
    # First argument is completely ignored here.
    sub _or_matcher {
        my (undef, @func) = @_;
        return sub {
            for (@func) {
                return 1 if $_->(@_);
            }
            return ();
        };
    }

    # Create string matcher function. Initial call returns a matcher function
    # (a coderef). For initial call, first arg (a hashref) contains options.
    # With 'field' falsy matches word-by-word, with 'field' truthy matches
    # against whole strings. With 'not' true, search logic is negated.
    #
    # Invoke coderef with a set of strings to test if they match. If matching
    # returns arrayrefs (one for each input string), otherwise undef. The
    # returned arrayrefs each contain a list of start/end offsets pinpointing
    # where in the string the match was found. Format (for each string):
    # [[BEG1,END1],[BEG2,END2]...]
    #
    # FIXME: For repeated matches, start searching at BEGINNING of previous match
    # position (+ 1) so as to find overlapping search terms.
    sub _atom_aggregator {
        my ($meta, @str) = @_;
        my $regex = _regexify($meta, @str);
        # Negative match. Return empty highlight data on match, undef
        # otherwise. (Stop on first match, for efficiency.)
        $meta->{not} and return sub {
            for (@_) { return () if m/$regex/ }
            return (map [], 1..@str);
        };
        # Positive match. Return highlight data on match, undef otherwise.
        # (Won't stop on first match, since we need all matches to be
        # highlighted.)
        return sub {
            my @pair = @_;
            my $found = '';
            my @out = map {
                my @mark;
                while (/$regex/g) {
                    push @mark, [$-[0], $+[0]];
                    # pos($_) = $-[0] + 1;
                }
                $found = 1 if @mark;
                \@mark;
            } @pair;
            return $found ? @out : ();
        };
    }

    # Combine elements in each arg with each other. Args are listrefs
    # containing listrefs. 1st listref of each input arg are combined into one
    # list and returned as 1st listref value, 2nd listref of each arg are
    # returned as 2nd value, etc.
    #
    # Each input value must be list-of-lists (which may contain whatever).
    #
    # Example: _aggregate([['a', 'b'], ['c']], [['1'], ['2', '3']])
    # Returns: (['a', 'b', '1'], ['c', '2', '3'])
    sub _aggregate {
        my @out;
        for my $arr (@_) {
            for my $i (0 .. $#$arr) {
                push @{ $out[$i] }, @{ $arr->[$i] };
            }
        }
        return @out;
    }

    # Create Boolean AND aggregator function. Initial call returns a Boolean
    # operator function (a coderef). For initial call, first arg is ignored,
    # the remaining are functions to be invoked by coderef call.
    #
    # Invoking coderef with a set of strings passes the given strings to each
    # callback in turn, and applies AND logic to their return values (zero
    # return values = false, one or more = true). Returns falsy/empty list if a
    # callback returns false (this also aborts running further callbacks),
    # Returns true if all callbacks return true.
    #
    # Callbacks are expected to return zero (=falsy) or more (=truthy)
    # listrefs-of-listrefs with highlight offset positions for the matches
    # found. A negated match may also return an empty listref (to indicate a
    # match with no highlights).
    sub _and_aggregator {
        my (undef, @func) = @_;
        return sub {
            # Invoke subexpressions (lazily = abort on first non-matching).
            return _aggregate(map {
                my @x = $_->(@_) or return (); # false = return immediately
                \@x;
            } @func);
        };
    }

    # Non-short circuiting in order to find all matches.
    sub _or_aggregator {
        my (undef, @func) = @_;
        return sub {
            # Invoke subexpressions (non-lazily, highlights needed for all).
            my $found = '';
            my @found = map {
                my @x = $_->(@_) and $found = 1;# true = remember it
                \@x;
            } @func;
            return $found ? _aggregate(@found) : ();
        };
    }

    # Compiles query and returns matcher function. This compiles the query tree
    # into a recursive function call, returning a query function which may then
    # be invoked (with a field name and value) to test whether that field and
    # value match. The query function returns either an array of highlight
    # positions (if were matches found), or undef (if no matches were found).
    sub _compile {
        my ($term, $opt) = @_;
        return $term unless ref($term);
        my ($meta, @data) = @$term;
        my $type = $meta->{type};
        my $func = $opt->{lang}{$type}
            // die "Unknown query term type: '$type'\n";
        $meta->{case} //= $opt->{case};
        return $func->($meta, map { _compile($_, $opt) } @data);
    }

    sub filter_stdout {
        my ($func, $end_func) = @_;
        pipe my $pipe_in, my $pipe_out or die "Pipe: $!";
        my $pid = fork() // die "Fork: $!";
        # Child (reads from pipe, writes to terminal).
        if ($pid > 0) {
            close $pipe_out;
            $func->($_) while <$pipe_in>;
            $end_func->();
            close $pipe_in;
            exit;
        }
        # Parent (STDOUT -> pipe).
        open STDOUT, '>&', $pipe_out or die "STDOUT to pipe: $!";
        close $pipe_in;
        close $pipe_out;
    }
    {
        my ($pass, $fail, $todo_pass, @todo_fail) = (0, 0, 0);
        sub line {
            local ($_) = @_; chomp;
            my $subtest = s/^\s+//;
            for ($_) {
                m/^\s*1\.\.[0-9]+        \b/x and                  return;
                m/^\s*not\sok\b.*\#\sTODO\b/x and do { push @todo_fail, $_; return };
                m/^\s*     ok\b.*\#\sTODO\b/x and do { $todo_pass += 1;     next   };
                m/^\s*not\sok            \b/x and do { $fail += 1; next   };
                m/^\s*     ok            \b/x and do { $pass += 1; return };
                m/^\s*[#]                  /x and do {
                    print "\e[36m$_\e[m\e[K\r"  # cyan
                        unless /no tests run/i;
                    return;
                };
            }
            my $beg =
                /^\s*not\sok\b.*\#\sTODO\b/x ? '32'    : # green  - not ok TODO
                /^\s*     ok\b.*\#\sTODO\b/x ? '1;7;33': # yellow - ok TODO
                /^\s*not\sok            \b/x ? '1;7;31': # red    - not ok
                /^\s*     ok            \b/x ? '32'    : # green  - ok
                /^\s*\#                   /x ? '36'    : # cyan   - #
                /^\s*1\.\.\d+           \b/x ? '35'    : # purple - 0..N
                '';
            say(($subtest && "\n") . "\e[${beg}m$_\e[0m\e[K");
        }
        sub done {
            say((
                $fail      ? "\e[1;31mFAIL!"       :
                $todo_pass ? "\e[1;33mUNEXPECTED FINISHED TODO!" :
                             "\e[1;32mALL PASSED!"
            ) . "\e[m (" . join(
                ' / ',
                ($fail      ? "\e[1;31m$fail failed\e[m"              : ()),
                ($todo_pass ? "\e[1;33m$todo_pass finished TODO\e[m"  : ()),
                ($pass      ? "\e[1;32m$pass passed\e[m"              : ()),
                (@todo_fail ? "\e[1;32m" . scalar(@todo_fail) . " remaining TODO\e[m" : ()),
            ) . ")\e[K");
            if ($todo_pass) {
                say "  (Turn above finished TODOs into a normal tests!)";
            } elsif (@todo_fail) {
                say "\e[1;33mREMAINING TODO:\e[m";
                say "  \e[33m* $_\e[m" for @todo_fail;
            }
        }
    }

    # FIXME: Test some actual queries
    #        my $record = record(<<~"END_RECORD");
    #            country	Greenland
    #            name	Anders Grönroot
    #            END_RECORD
    sub test {
        my ($color) = @_;
        filter_stdout(\&line, \&done) if $color;
        require Test::More;                    # load at runtime
        import Test::More;                     #   (not compile time)
        sub subtest;
        our $TODO;
        # Modify 'is_deeply()' for better diagnostics.
        state sub is_deeply {
            my ($have, $want, $msg) = @_;
            local $Test::Builder::Level = $Test::Builder::Level + 1;
            Test::More::is_deeply($have, $want, $msg)
                or diag("\e[41mHAVE: ${\debug($have)}\e[49m\n",
                        "\e[42mWANT: ${\debug($want)}\e[49m\n");
        }
        state sub query_is {
            my ($query_str, $want, $msg) = @_;
            $query_str //= '';
            $msg       //= '';
            local $Test::Builder::Level = $Test::Builder::Level + 1;
            is_deeply(_parse($query_str), $want,
                      "query: «$query_str»" . ($msg && " ($msg)"));
        }
        sub dies_with(&$;$) {
            my ($code, $str, $name) = @_;
            local $@;
            local $Test::Builder::Level = $Test::Builder::Level + 1;
            my $regex = qr/^\Q$str/;
            if (eval { $code->(); 1 }) {       # no exception thrown
                fail($name);
                note("Expected code to die, but it ran to completion");
                return ();
            }
            my $err = $@;
            if ($err =~ $regex) {
                pass($name);
                return 1;
            }
            fail($name);                       # wrong error message
            diag("expected: '$str' (at start of error message)\n",
                 "     got: '$err'");
            return ();
        }
        state sub TODO {
            my ($msg, $coderef, @args) = @_;
            Test::More::subtest("TODO $msg", sub {
                local $TODO = 'Not Yet Implemented';
                $coderef->(@_);
            }, @args);
        }

        state sub atom {
            my ($atom, %opt) = @_;
            return [
                { type => 'atom', field => 0, not => 0, quote => '', %opt },
                map { quotemeta $_ } ($atom // '') =~ /\X/gu,
            ];
        }
        state sub or  { [{ type => 'or',  field => 0, not => 0 }, @_] }
        state sub and { [{ type => 'and', field => 0, not => 0 }, @_] }
        state sub neg   { my $x = shift; die "Too many args" if @_; $x->[0]{not}   = 1; $x }
        state sub field { my $x = shift; die "Too many args" if @_; $x->[0]{field} = 1; $x }

        subtest 'QUERY NORMALIZATION (-> NEGATION NORMAL FORM)' => sub {
            subtest "Atoms (=don't modify)" => sub {
                is_deeply(_normalize(atom()), atom(), '«x»');
                is_deeply(_normalize(neg(atom())), neg(atom()), '«-x»');
                is_deeply(_normalize(field(atom())), field(atom()), '«=x»');
                is_deeply(_normalize(neg(field(atom()))), neg(field(atom())), '«-=x»');
            };
            subtest "Atoms + 'not' arg (=set 'not' attribute)" => sub {
                is_deeply(_normalize(atom(), 1), neg(atom()), '«x» -> «-x»');
                is_deeply(_normalize(neg(atom()), 1), atom(), '«-x» -> «x»');
                is_deeply(_normalize(field(atom()), 1), neg(field(atom())), '«=x» -> «-=x»');
                is_deeply(_normalize(neg(field(atom())), 1), field(atom()), '«-=x» -> «=x»');
            };
            subtest "Atoms + 'field' arg (=set 'field' attribute)" => sub {
                is_deeply(_normalize(atom(), 0, 1), field(atom()), '«x» -> «=x»');
                is_deeply(_normalize(neg(atom()), 0, 1), neg(field(atom())), '«-x» -> «-=x»');
                is_deeply(_normalize(field(atom()), 0, 1), atom(), '«=x» -> «x»');
                is_deeply(_normalize(neg(field(atom())), 0, 1), neg(atom()), '«-=x» -> «-x»');
            };
            subtest "Atoms + both 'not' and 'field' arg (=set both attributes)" => sub {
                is_deeply(_normalize(atom(), 1, 1), neg(field(atom())), '«x» -> «-=x»');
                is_deeply(_normalize(neg(atom()), 1, 1), field(atom()), '«-x» -> «=x»');
                is_deeply(_normalize(field(atom()), 1, 1), neg(atom()), '«=x» -> «-x»');
                is_deeply(_normalize(neg(field(atom())), 1, 1), atom(), '«-=x» -> «x»');
            };
            subtest "Simple parentheses (De Morgan's Law + 'field' attribute)" => sub {
                is_deeply(_normalize(      and(atom('a'),    neg(atom('b')) )), and(      atom('a'),    neg(atom('b'))), '« ( a -b)» -> «( a -b)»');
                is_deeply(_normalize(  neg(and(atom('a'),    neg(atom('b'))))),  or(  neg(atom('a')),       atom('b') ), '«-( a -b)» -> «(-a, b)»');
                is_deeply(_normalize(       or(atom('a'),    neg(atom('b')) )),  or(      atom('a'),    neg(atom('b'))), '« ( a,-b)» -> «( a,-b)»');
                is_deeply(_normalize(  neg( or(atom('a'),    neg(atom('b'))))), and(  neg(atom('a')),       atom('b') ), '«-( a,-b)» -> «(-a  b)»');
                is_deeply(_normalize(      and(atom('a'),  field(atom('b')) )), and(      atom('a'),  field(atom('b'))), '« ( a =b)» -> «( a =b)»');
                is_deeply(_normalize(field(and(atom('a'),  field(atom('b'))))), and(field(atom('a')),       atom('b') ), '«=( a =b)» -> «(=a  b)»');
                is_deeply(_normalize(       or(atom('a'),  field(atom('b')) )),  or(      atom('a'),  field(atom('b'))), '« ( a,=b)» -> «( a,=b)»');
                is_deeply(_normalize(field( or(atom('a'),  field(atom('b'))))),  or(field(atom('a')),       atom('b') ), '«=( a,=b)» -> «(=a, b)»');
            };
        };
        subtest '_atom_matcher() -- word mode' => sub {
            my $matcher = eval { _atom_matcher(@{ atom('x') }) };
            is(ref($matcher), 'CODE', 'Return coderef');
            is("$@", '', 'Error message') or diag("Error: $@");
            is_deeply([ $matcher->('x') ], [1], "Match whole word");
            is_deeply([ $matcher->('', 'x') ], [1], "Match in second field");
            is_deeply([ $matcher->('x x') ], [1], 'Match multiple words in same field');
            is_deeply([ $matcher->('xx') ], [], "Don't match part of word");
            is_deeply([ $matcher->('') ], [], "Don't match empty string");
        };
        subtest '_atom_matcher() -- field mode' => sub {
            my $matcher = eval { _atom_matcher(@{ atom('x', field => 1) }) };
            is(ref($matcher), 'CODE', 'Return coderef');
            is("$@", '', 'Error message') or diag("Error: $@");
            is_deeply([ $matcher->('x') ], [1], "Match whole field");
            is_deeply([ $matcher->('', 'x') ], [1], "Match in second field");
            is_deeply([ $matcher->('x x') ], [], "Don't match part of field");
            is_deeply([ $matcher->('xx') ], [], "Don't match part of word");
            is_deeply([ $matcher->('') ], [], "Don't match empty string");
        };
        subtest '_atom_matcher() -- negated' => sub {
            my $matcher = eval { _atom_matcher(@{ atom('x', not => 1) }) };
            is(ref($matcher), 'CODE', 'Return coderef');
            is("$@", '', 'Error message') or diag("Error: $@");
            is_deeply([ $matcher->('x') ], [], "Don't match a whole field");
            is_deeply([ $matcher->('', 'x') ], [], "Don't match if in second field");
            is_deeply([ $matcher->('x x') ], [], 'Match multiple words in same field');
            is_deeply([ $matcher->('xx') ], [1], "Don't match as part of a word");
            is_deeply([ $matcher->('') ], [1], "Match empty string");
        };
        subtest '_and_matcher()' => sub {
            note('Allowed callback return values');
            is_deeply([ _and_matcher(undef, sub { 'x' })->() ], [1], 'Single truthy');
            is_deeply([ _and_matcher(undef, sub {   1 })->() ], [1], 'Single truthy');
            is_deeply([ _and_matcher(undef, sub {  '' })->() ], [], 'Single falsy');
            is_deeply([ _and_matcher(undef, sub {   0 })->() ], [], 'Single falsy');
            note('Test Boolean functions');
            is_deeply([ _and_matcher(undef, sub { 0 }, sub { 0 })->() ],
                      [], 'Two falsy = falsy');
            is_deeply([ _and_matcher(undef, sub { 0 }, sub { 1 })->() ],
                      [], 'Falsy + truthy = falsy');
            is_deeply([ _and_matcher(undef, sub { 1 }, sub { 0 })->() ],
                      [], 'Truthy + falsy = falsy');
            is_deeply([ _and_matcher(undef, sub { 1 }, sub { 1 })->() ],
                      [1], 'Two truthy = truthy');
            note('Test that input is passed to (invoked) callbacks');
            my ($x, $y, $z);
            is_deeply([ _and_matcher(
                undef,
                sub { $x = \@_; 1 },
                sub { $y = \@_; 0 },  # returns false
                sub { $z = \@_; 1 },  #   thus this func won't run
            )->('INPUT') ], [], 'Return value');
            is_deeply($x, ['INPUT'], '1st subfunction get args');
            is_deeply($y, ['INPUT'], '2nd subfunction get args');
            is_deeply($z, undef, "3rd function short-circuited, don't get args");
        };
        subtest '_or_matcher()' => sub {
            note('Allowed callback return values');
            is_deeply([ _or_matcher(undef, sub { 'x' })->() ], [1], 'Single truthy');
            is_deeply([ _or_matcher(undef, sub {   1 })->() ], [1], 'Single truthy');
            is_deeply([ _or_matcher(undef, sub {  '' })->() ], [], 'Single falsy');
            is_deeply([ _or_matcher(undef, sub {   0 })->() ], [], 'Single falsy');
            note('Test Boolean functions');
            is_deeply([ _or_matcher(undef, sub { 0 }, sub { 0 })->() ],
                      [], 'Two falsy = falsy');
            is_deeply([ _or_matcher(undef, sub { 0 }, sub { 1 })->() ],
                      [1], 'Falsy + truthy = truthy');
            is_deeply([ _or_matcher(undef, sub { 1 }, sub { 0 })->() ],
                      [1], 'Truthy + falsy = truthy');
            is_deeply([ _or_matcher(undef, sub { 1 }, sub { 1 })->() ],
                      [1], 'Two truthy = truthy');
            note('Test that input is passed to (invoked) callbacks');
            my ($x, $y, $z);
            is_deeply([ _or_matcher(
                undef,
                sub { $x = \@_; 0 },
                sub { $y = \@_; 1 },  # returns true
                sub { $z = \@_; 0 },  #   thus this func won't run
            )->('INPUT') ], [1], 'Return value');
            is_deeply($x, ['INPUT'], '1st subfunction get args');
            is_deeply($y, ['INPUT'], '2nd subfunction get args');
            is_deeply($z, undef, "3rd function short-circuited, don't get args");
        };
        subtest '_aggregate()' => sub {
            dies_with(sub { _aggregate('x') },
                q{Can't use string ("x") as an ARRAY ref}, 'Args must be arrayrefs, not string');
            dies_with(sub { _aggregate([], 'x') },
                q{Can't use string ("x") as an ARRAY ref}, 'Args must be arrayrefs');
            dies_with(sub { _aggregate(['x']) },
                q{Can't use string ("x") as an ARRAY ref}, 'Args must be arrayrefs containing arrayrefs');
            is_deeply([ _aggregate() ], [], "No args returns empty arrayref");
            is_deeply([ _aggregate([]) ], [], 'One empty arrayref returns empty arrayref');
            is_deeply([ _aggregate([], []) ], [], 'Two empty arrayrefs returns empty arrayref');
            is_deeply([ _aggregate([[]]) ], [[]], 'Args must be arrayrefs containing arrayrefs');
            is_deeply([ _aggregate([['x']]) ], [['x']], 'Args must be arrayrefs containing arrayrefs');
            is_deeply([ _aggregate([[qw/x y/]]) ], [[qw/x y/]], 'Args must be arrayrefs containing arrayrefs');
            is_deeply([ _aggregate([[qw/a b/], [qw/x y/]]) ], [[qw/a b/], [qw/x y/]],
                      'Args must be arrayrefs containing arrayrefs');
            is_deeply([ _aggregate(
                [['a'], [qw/c d/], [qw/e f g/], []],
                [['i'], [qw/j k/], [qw/l m n/], [qw/o p/]],
            ) ], [
                [qw/a i/],
                [qw/c d j k/],
                [qw/e f g l m n/],
                [qw/o p/],
            ], 'Combine each listref arg with each other');
        };
        subtest '_atom_aggregator() -- word mode' => sub {
            my $matcher = eval { _atom_aggregator(@{ atom('x') }) };
            is("$@", '', 'Error message') or diag("Error: $@");
            is(ref($matcher), 'CODE', 'Return coderef');
            is_deeply([ $matcher->('x') ], [[[0,1]]], "Match whole word");
            is_deeply([ $matcher->('', 'x') ], [[], [[0,1]]], "Match in second field");
            is_deeply([ $matcher->('x x') ], [[[0,1], [2,3]]], 'Match multiple words in same field');
            is_deeply([ $matcher->('xx') ], [], "Don't match part of word");
            is_deeply([ $matcher->('') ], [], "Don't match empty string");
        };
        subtest '_atom_aggregator() -- field mode' => sub {
            my $matcher = eval { _atom_aggregator(@{ atom('x', field => 1) }) };
            is(ref($matcher), 'CODE', 'Return coderef');
            is("$@", '', 'Error message') or diag("Error: $@");
            is_deeply([ $matcher->('x') ], [[[0,1]]], "Match whole field");
            is_deeply([ $matcher->('', 'x') ], [[], [[0,1]]], "Match in second field");
            is_deeply([ $matcher->('x x') ], [], "Don't match part of field");
            is_deeply([ $matcher->('xx') ], [], "Don't match part of word");
            is_deeply([ $matcher->('') ], [], "Don't match empty string");
        };
        subtest '_atom_aggregator() -- negated' => sub {
            my $matcher = eval { _atom_aggregator(@{ atom('x', not => 1) }) };
            is(ref($matcher), 'CODE', 'Return coderef');
            is("$@", '', 'Error message') or diag("Error: $@");
            is_deeply([ $matcher->('x') ], [], "Don't match a whole field");
            is_deeply([ $matcher->('', 'x') ], [], "Don't match if in second field");
            is_deeply([ $matcher->('x x') ], [], 'Match multiple words in same field');
            is_deeply([ $matcher->('xx') ], [[]], "Don't match as part of a word");
            is_deeply([ $matcher->('') ], [[]], "Match empty string");
        };
        subtest '_and_aggregator()' => sub {
            note('Allowed callback return values');
            dies_with(
                sub { _and_aggregator(undef, sub { 'a' })->() },
                q{Can't use string ("a") as an ARRAY ref},
                'Callback may not return string');
            is_deeply(
               [ _and_aggregator(
                    undef,
                    sub { ['a'] }
                )->() ], [['a']],
                'Callbacks may return single listref');
            is_deeply(
                [ _and_aggregator(
                    undef,
                    sub { (['1a'], ['2b']        ) },
                    sub { (['1c',   '1d']        ) },
                    sub { ([    ], ['2e']        ) },
                    sub { ([    ], [    ], ['3f']) },
                )->() ],
                [['1a', '1c', '1d'], ['2b', '2e'], ['3f']],
                'Callbacks may return multiple listrefs, which are combined');
            is_deeply([ _and_aggregator(undef)->() ],
                      [], 'No callbacks set up = return falsy');
            is_deeply([ _and_aggregator(undef, sub { [] })->() ],
                      [[]], 'Single truthy');
            is_deeply([ _and_aggregator(undef, sub { () })->() ],
                      [], 'Single falsy');
            note('Test Boolean functions');
            is_deeply([ _and_aggregator(undef, sub { () }, sub { () })->() ],
                      [], 'Two falsy = falsy');
            is_deeply([ _and_aggregator(undef, sub { () }, sub { [] })->() ],
                      [], 'Falsy + truthy = falsy');
            is_deeply([ _and_aggregator(undef, sub { [] }, sub { () })->() ],
                      [], 'Truthy + falsy = falsy');
            is_deeply([ _and_aggregator(undef, sub { [] }, sub { [] })->() ],
                      [[]], 'Two truthy = truthy');
            note('Test that input is passed to (invoked) callbacks');
            my ($x, $y, $z);
            is_deeply(
                [ _and_aggregator(
                    undef,
                    sub { $x = \@_; (['a']) },
                    sub { $y = \@_; ()      }, # returns false
                    sub { $z = \@_; (['b']) }, #   thus this func won't run
                )->(qw/a b/) ],
                [], 'Return value');
            is_deeply($x, [qw/a b/], '1st callback get args');
            is_deeply($y, [qw/a b/], '2nd callback get args');
            is_deeply($z, undef,
                      "3rd callback short-circuited, don't get args");
        };
        subtest '_or_aggregator()' => sub {
            note('Allowed callback return values');
            dies_with(
                sub { _or_aggregator(undef, sub { 'a' })->() },
                q{Can't use string ("a") as an ARRAY ref},
                'Callback may not return string');
            is_deeply(
               [ _or_aggregator(
                    undef,
                    sub { ['a'] }
                )->() ], [['a']],
                'Callbacks may return single listref');
            is_deeply(
                [ _or_aggregator(
                    undef,
                    sub { (['1a'], ['2b']        ) },
                    sub { (['1c',   '1d']        ) },
                    sub { ([    ], ['2e']        ) },
                    sub { ([    ], [    ], ['3f']) },
                )->() ],
                [['1a', '1c', '1d'], ['2b', '2e'], ['3f']],
                'Callbacks may return multiple listrefs, which are combined');
            is_deeply([ _or_aggregator(undef)->() ],
                      [], 'No callbacks set up = return falsy');
            is_deeply([ _or_aggregator(undef, sub { [] })->() ],
                      [[]], 'Single truthy');
            is_deeply([ _or_aggregator(undef, sub { () })->() ],
                      [], 'Single falsy');
            note('Test Boolean functions');
            is_deeply([ _or_aggregator(undef, sub { () }, sub { () })->() ],
                      [], 'Two falsy = falsy');
            is_deeply([ _or_aggregator(undef, sub { () }, sub { [] })->() ],
                      [[]], 'Falsy + truthy = truthy');
            is_deeply([ _or_aggregator(undef, sub { [] }, sub { () })->() ],
                      [[]], 'Truthy + falsy = truthy');
            is_deeply([ _or_aggregator(undef, sub { [] }, sub { [] })->() ],
                      [[]], 'Two truthy = truthy');
            note('Test that input is passed to (invoked) callbacks');
            my ($x, $y, $z);
            is_deeply(
                [ _or_aggregator(
                    undef,
                    sub { $x = \@_; () },
                    sub { $y = \@_; (['a']) }, # returns true
                    sub { $z = \@_; () },      #   but this func runs anyway
                )->(qw/a b/) ],
                [['a']], 'Return value');
            is_deeply($x, [qw/a b/], '1st callback get args');
            is_deeply($y, [qw/a b/], '2nd callback get args');
            is_deeply($z, [qw/a b/],
                      "3rd callback short-circuited, don't get args");
        };
        subtest 'QUERY BASICS' => sub {
            query_is(''      => or());
            query_is('a'     => atom('a'));
            query_is('ab'    => atom('ab'));
            query_is('-ab'   => neg(atom('ab')), 'negated');
            query_is('--ab'  => atom('ab'), 'double negation = none');
            query_is('---ab' => neg(atom('ab')), 'negated');
            query_is('=ab'   => field(atom('ab')), 'field search');
            query_is('==ab'  => atom('ab'), 'double field search = none');
            query_is('===ab' => field(atom('ab')), 'field search');
            query_is('a b'   => and(atom('a'), atom('b')), 'and');
            query_is('a,b'   => or(atom('a'), atom('b')), 'or');
            query_is('a b,c' => or(and(atom('a'), atom('b')), atom('c')), 'priority');
            query_is('a,b c' => or(atom('a'), and(atom('b'), atom('c'))), 'priority');
            query_is('a -b,c' => or(and(atom('a'), neg atom('b')), atom('c')), 'priority');
            query_is('a,-b c' => or(atom('a'), and(neg(atom('b')), atom('c'))), 'priority');
        };
        subtest 'PARENTHESIS IN QUERY' => sub {
            query_is('(a)'     => atom('a'));
            query_is('(a)b'    => and(atom('a'), atom('b')));
            query_is('(a b)'   => and(atom('a'), atom('b')));
            query_is('(a,b)'   => or(atom('a'), atom('b')));
            query_is('((a,b))' => or(atom('a'), atom('b')));
        };
        subtest 'UNBALANCED PARENTHESES' => sub {
            query_is( ') '     => or());
            query_is( ')'      => or());
            query_is( ') b'    => atom('b'));
            query_is('a) b'    => and(atom('a'), atom('b')));
            query_is('a)'      => atom('a'));
            query_is('a))'     => atom('a'));
            query_is('a)b'     => and(atom('a'), atom('b')));
            query_is('a)b)c'   => and(atom('a'), atom('b'), atom('c')));
            query_is('a)b)c)'  => and(atom('a'), atom('b'), atom('c')));
            query_is( ')b'     => atom('b'));
            query_is( '),b'    => atom('b'));
            query_is('a),'     => atom('a'));
            query_is('a),b'    => or(atom('a'), atom('b')));

            query_is( '(b'     => atom('b'));
            query_is('a(b'     => and(atom('a'), atom('b')));
            query_is('((c'     => atom('c'));
            query_is('a(b(c'   => and(atom('a'), and(atom('b'), atom('c'))));
            query_is('a(b(c,'  => and(atom('a'), and(atom('b'), atom('c'))));
            query_is('a(b,(c'  => and(atom('a'), or(atom('b'), atom('c'))));
        };
        subtest 'QUOTED STRINGS' => sub {
            query_is('"()"'  => atom('()'));
            query_is('-"a"'  => neg(atom('a')));
            query_is('"-a"'  => atom('-a'));
            query_is('-"-a"' => neg(atom('-a')));
        };
        subtest 'NEGATION PROPAGATION' => sub {
            query_is('-a'      => neg(atom('a')));
            query_is('--a'     => atom('a'), 'means «a»');
            query_is('-(a)'    => neg(atom('a')), 'means «-a»');
            query_is('-(-a)'   => atom('a'), 'means «a»');
            query_is('-(a -b)' => neg(and(atom('a'), neg atom('b'))), 'means «(-a,b)» -- FIXME De Morgan');
            query_is('-(a,-b)' => neg(or(atom('a'), neg(atom('b')))), 'means «(-a b)» -- FIXME De Morgan');
            TODO "Push 'not' to leaf nodes" => sub {
                query_is('-(a -b)' => or(neg(atom('a')), atom('b')), 'means «(-a,b)»');
                query_is('-(a,-b)' => or(neg(atom('a')), atom('b')), 'means «(-a b)»');
            };
        };
        subtest 'FIELD PROPAGATION' => sub {
            query_is('=(a)'    => field(atom('a')), 'means «=a»');
            query_is('=(=a)'   => atom('a'), 'means «a»');
            query_is('=(a =b)' => field(and(atom('a'), field atom('b'))), 'means «=a b» FIXME');
            query_is('=(a,=b)' => field(or(atom('a'), field(atom('b')))), 'means «=a,b» FIXME');
            TODO "Push 'field' to leaf nodes" => sub {
                query_is('=(a =b)' => and(field(atom('a')), atom('b')), 'means «=a b»');
                query_is('=(a,=b)' => or(field(atom('a')), atom('b')), 'means «=a,b»');
            };
        };
        note("SLOPPY QUERY TESTS\n",
             '(from https://zrajm.org/teckentranskription/lexicon-tests.html)');
        subtest '1. Simplest tests' => sub {
            query_is('a'      => atom('a'),                      '1.1');
            query_is('-a'     => neg(atom('a')),                 '1.2');
            query_is('a b'    => and(atom('a'), atom('b')),      '1.3');
            query_is('(a b)'  => and(atom('a'), atom('b')),      '1.4');
            query_is('-(a b)' => neg(and(atom('a'), atom('b'))), '1.5');
        };
        subtest '2. Missing start parenthesis' => sub {
            query_is('a)' => atom('a'), '2.1');
            query_is('a b)' => and(atom('a'), atom('b')), '2.2');
            query_is('a b) c' => and(atom('a'), atom('b'), atom('c')), '2.3');
            TODO "EXPECTED (should work, but doesn't)" => sub {
                query_is('a, b) c'  => and(or(atom('a'), atom('b')), atom('c')), '2.4');
                query_is('a b), c' => or(and(atom('a'), atom('b')), atom('c')), '2.5');
                query_is('a, b), c' => or(or(atom('a'), atom('b')), atom('c')), '2.6');
                query_is('a, b), c d' => or(or(atom('a'), atom('b')), and(atom('c'), atom('d'))), '2.7');
                query_is('a, b) (c, d)' => and(or(atom('a'), atom('b')), or(atom('c'), atom('d'))), '2.8');
            };
            query_is('(a, b) c' => and(or(atom('a'), atom('b')), atom('c')), '2.4b INCORRECT -- replace by above TODO');
            query_is('(a b), c' => or(and(atom('a'), atom('b')), atom('c')), '2.5b INCORRECT -- replace by above TODO');
            query_is('(a, b), c' => or(or(atom('a'), atom('b')), atom('c')), '2.6b INCORRECT -- replace by above TODO');
            query_is('(a, b), c d' => or(or(atom('a'), atom('b')), and(atom('c'), atom('d'))), '2.7b INCORRECT -- replace by above TODO');
            query_is('(a, b) (c, d)' => and(or(atom('a'), atom('b')), or(atom('c'), atom('d'))), '2.8b INCORRECT -- replace by above TODO');
        };
        subtest '3. Missing end parenthesis' => sub {
            query_is('(a' => atom('a'), '3.1');
            query_is('(a b)' => and(atom('a'), atom('b')), '3.2');
            TODO "EXPECTED (should work, but doesn't)" => sub {
                query_is('a (b c' => and(atom('a'), atom('b'), atom('c')), '3.3');
            };
            query_is('a (b c' => and(atom('a'), and(atom('b'), atom('c'))), '3.3b INCORRECT -- replace by above TODO');
            query_is('a, (b c' => or(atom('a'), and(atom('b'), atom('c'))), '3.4');
            query_is('a (b, c' => and(atom('a'), or(atom('b'), atom('c'))), '3.5');
            TODO "EXPECTED (should work, but doesn't)" => sub {
                query_is('a, (b, c' => or(atom('a'), atom('b'), atom('c')), '3.6');
                query_is('a b, (c, d' => or(and(atom('a'), atom('b')), atom('c'), atom('d'), '3.7'));
            };
            query_is('a, (b, c' => or(atom('a'), or(atom('b'), atom('c'))), '3.6b INCORRECT -- replace by above TODO');
            query_is('a b, (c, d' => or(and(atom('a'), atom('b')), or(atom('c'), atom('d'))), '3.7b INCORRECT -- replace by above TODO');
            query_is('(a, b) (c, d' => and(or(atom('a'), atom('b')), or(atom('c'), atom('d'))), '3.8');
        };
        subtest '4. Explicit parens' => sub {
            TODO "EXPECTED (should work, but doesn't)" => sub {
                query_is('a, b) c' => and(or(atom('a'), atom('b')), atom('c')), '4.1');
            };
            query_is('(a, b) c' => and(or(atom('a'), atom('b')), atom('c')), '4.1b INCORRECT -- replace by above TODO');
            query_is('a, b c' => or(atom('a'), and(atom('b'), atom('c'))), '4.2');
            query_is('a b, c' => or(and(atom('a'), atom('b')), atom('c')), '4.3');
            query_is('(a b), c' => or(and(atom('a'), atom('b')), atom('c')), '4.4');
            query_is('(a, b) c' => and(or(atom('a'), atom('b')), atom('c')), '4.5');
        };
        subtest '5. Implicit parens' => sub {
            query_is('a b, c' => or(and(atom('a'), atom('b')), atom('c')), '5.1');
            query_is('a, b c' => or(atom('a'), and(atom('b'), atom('c'))), '5.2');
            query_is('a b c, d' => or(and(atom('a'), atom('b'), atom('c')), atom('d')), '5.3');
            query_is('a, b c d' => or(atom('a'), and(atom('b'), atom('c'), atom('d'))), '5.4');
            query_is('a b, c d' => or(and(atom('a'), atom('b')), and(atom('c'), atom('d'))), '5.5');
            query_is('a b c, d e f' => or(and(atom('a'), atom('b'), atom('c')), and(atom('d'), atom('e'), atom('f'))), '5.6');
            query_is('a, b c, d' => or(atom('a'), and(atom('b'), atom('c')), atom('d')), '5.7');
            query_is('a b, c d e, f g' => or(and(atom('a'), atom('b')), and(atom('c'), atom('d'), atom('e')), and(atom('f'), atom('g'))), '5.8');
            query_is('a b, c' => or(and(atom('a'), atom('b')), atom('c')), '5.9');
            query_is('((a, b c) e, f)' => or(and(or(atom('a'), and(atom('b'), atom('c'))), atom('e')), atom('f')), '5.10');
            TODO "EXPECTED (should work, but doesn't)" => sub {
                query_is('((a b, c), e f)' => or(and(atom('a'), atom('b')), atom('c'), and(atom('e'), atom('f'))), '5.11');
            };
            query_is('((a b, c), e f)' => or(or(and(atom('a'), atom('b')), atom('c')), and(atom('e'), atom('f'))), '5.11b INCORRECT -- replace by above TODO');
        };
        subtest '6. Single item in parenthesis' => sub {
            query_is('a' => atom('a'), '6.1');
            query_is('-a' => neg(atom('a')), '6.2');
            query_is('--a' => atom('a'), '6.3');
            query_is('---a' => neg(atom('a')), '6.4');
            query_is('(a)' => atom('a'), '6.5');
            query_is('(-a)' => neg(atom('a')), '6.6');
            query_is('-(a)' => neg(atom('a')), '6.7');
            query_is('-(-a)' => atom('a'), '6.8');
            query_is('(-(-a))' => atom('a'), '6.9');
            query_is('-(-(-a))' => neg(atom('a')), '6.10');
        };
        subtest '7. Removal of empty paren' => sub {
            query_is('a () b' => and(atom('a'), atom('b')), '7.1');
            query_is('a -() b' => and(atom('a'), atom('b')), '7.2');
        };
        subtest '8. Leading space or comma should not affect paren' => sub {
            query_is('(,a b)' => and(atom('a'), atom('b')), '8.1');
            query_is('( a,b)' => or(atom('a'), atom('b')), '8.2');
        };
        subtest '9. Unwrapping of parenthesis with same AND/OR as parent' => sub {
            TODO "EXPECTED (should work, but doesn't)" => sub {
                query_is('(a b) c' => and(atom('a'), atom('b'), atom('c')), '9.1');
                query_is('a (b c)' => and(atom('a'), atom('b'), atom('c')), '9.2');
                query_is('(a, b), c' => or(atom('a'), atom('b'), atom('c')), '9.3');
            };
            query_is('(a b) c' => and(and(atom('a'), atom('b')), atom('c')), '9.1b INCORRECT -- replace by above TODO');
            query_is('a (b c)' => and(atom('a'), and(atom('b'), atom('c'))), '9.2b INCORRECT -- replace by above TODO');
            query_is('(a, b), c' => or(or(atom('a'), atom('b')), atom('c')), '9.3b INCORRECT -- replace by above TODO');
        };
        done_testing();
    }
}

###############################################################################

sub whenarg {
    my ($arg) = @_;
    my $opt = do {
        local $_ = $arg // $ARGV[0] // '';
        /^(auto  |if-tty|tty)$/x ? -t STDOUT :
        /^(always|force |yes)$/x ?         1 :
        /^(never |none  |no )$/x ?        '' : undef;
    };
    if (defined $opt) {                        # option found
        shift @ARGV if not defined($arg);      # '--color WHEN' (w/o equals)
        return $opt;
    }
    # Option value not found.
    die "Unknown argument '$arg' for '--color'\n",
        "Valid arguments are:\n",
        "  - 'always', 'yes', 'force'\n",
        "  - 'never', 'no', 'none'\n",
        "  - 'auto', 'tty', 'if-tty'.\n"
        if defined($arg);                      # '--color=WHEN' (w/ equals)
    return 1;
}

###############################################################################
# Main

local %SIG = (
    __WARN__ => sub { warn("$PROGRAM: @_") },
    __DIE__  => sub {
        die @_ if $^S;                         # abort if called inside eval
        # Perl can insert 'at FILE line NUM.': Don't add tips for that.
        my $tip = (my $msg = "@_") =~ s/(?<!\d)\.$//; # ends in '.' = show tip
        die("$PROGRAM: $msg",
            $tip ? "Try '$PROGRAM --help' for more information.\n" : ());
    });

my (@arg, @query);
my $to_write = '';
%opt = (
    case   => -1,                              # -1: smart, 0: exact, 1: ignore
    color  => -t STDOUT,
    file   => '',
    info   => '',
    man    => '',
    pager  => $ENV{PAGER} // $ENV{ZDBPAGER} // 'pager',
    paging => -t STDOUT,
    test   => 0,
    verbose=> '',
    write  => '',
);
@ARGV = map { decode } @ARGV;
while (@ARGV) {
    local $_ = shift;
    # NOTE! Shortopts with args must be in (negated) character class below!
    s/(?<=^-[^-e]).+//x            and unshift(@ARGV, "-$&"); # bundled opts
    /^        --               $/x and do { push(@arg, @ARGV);          last };
    /^(-s    |--case-sensitive)$/x and do { $opt{case}  = 1;            next };
    /^ -c                      $/x and do { $opt{color} = 1;            next };
    /^(-C    |--no-colou?r    )$/x and do { $opt{color} = 0;            next };
    /^        --colou?r(=(.*))?$/x and do { $opt{color} = whenarg($2);  next };
    /^(-e(.*)|--match (=(.*))?)$/x and do { push @query, $2||$4//shift; next };
    /^(-h    |--help          )$/x and do { $opt{info} = $USAGE;        next };
    /^(       --help-query    )$/x and do { $opt{info} = $QUERY;        next };
    /^(-i    |--ignore-case   )$/x and do { $opt{case} = '';            next };
    /^(-I    |--no-ignore-case)$/x and do { $opt{case} =  1;            next };
    /^(-M    |--man(ual)?     )$/x and do { $opt{man} = 1;              next };
    /^        --pager  (=(.*))?$/x and do { $opt{pager} = $2//shift;    next };
    /^        --paging (=(.*))?$/x and do { $opt{paging} = whenarg($2); next };
    /^ -p                      $/x and do { $opt{paging} = 1;           next };
    /^(-P    |--no-paging     )$/x and do { $opt{paging} = 0;           next };
    /^(-S    |--smart-case    )$/x and do { $opt{case} = -1;            next };
    /^(       --no-smart-case )$/x and do { $opt{case} =  1;            next };
    /^(       --test          )$/x and do { $opt{test} = 1;             next };
    /^(-v    |--verbose       )$/x and do { $opt{verbose} = 1;          next };
    /^(       --version       )$/x and do { $opt{info} = version();     next };
    /^((?!\d)\w+)        =(.*) $/x and do { $to_write .= "$1\t$2\n";    next };
    die "Unknown option '${ s/=.*//; \$_ }'.\n" if /^-./;
    push(@arg, $_);
}

$opt{man}  and manpage();
$opt{test} and do { Query::test($opt{color}); exit };
$opt{info} and do { print $opt{info}; exit };
die "Only one FILE may be specified.\n" if @arg > 2;
if (-t STDIN) {                                # get FILE
    die "No FILE specified.\n"                         if @arg == 0;
    die "FILE is '-' but no standard input to read.\n" if $arg[$#arg] eq '-';
    die "FILE '$arg[$#arg]' does not exist.\n"         if not -e $arg[$#arg];
    ($opt{file}) = pop @arg;
} else {                                       # read STDIN
    pop @arg if (@arg && $arg[$#arg] eq '-');
    die "Specify either FILE or standard input, not both.\n" if @arg > 1;
}
@query = shift(@arg) if @arg and !@query;      # get QUERY arg (not -eQUERY)
die "No QUERY and/or FIELD=VALUE(s) given.\n" unless @query or $to_write;

# FIXME: split $opt{pager} (?)
$pager_pid = open(STDOUT, '|-', $opt{pager})   # send all STDOUT through pager
    or die "Can't exec '$opt{pager}': $!\n"    #   (if enabled)
    if $opt{paging};

if ($to_write) {
    $opt{color} = 0;
    $opt{write} = 1;
}
my $query_str = join(',', @query);
$opt{case} = ($query_str =~ /\p{Uppercase}/u) if $opt{case} eq -1;
my $query = new Query($query_str, {
    lang => $opt{color} ? 'color' : 'plain',
    case => $opt{case},
});
my $zdb = new ZDB(
    file  => $opt{file},                       # input file
    write => $opt{write},                      # write mode?
);

say 'QUERY: ' . new Query(join(',', @query), { lang => 'dump' })->()
    if $opt{verbose};

my $out = '';
while (my ($prespace, @field) = $zdb->read_record()) {
    my @found = $query->(map @{$_}[qw/0 1/], @field); # search field name/value
    next unless @found or $opt{write};

    # FIELD=VALUE(s) but no QUERY. Output new record at end.
    if (not @query and $zdb->eof()) {
        $out .= "\n";
        if ($to_write) {
            $out .= $to_write;
            $to_write = '';
        }
    }
    # Output record (possibly with highlight, possibly not).
    $out .= $prespace;
    while (@field) {
        my ($field, $value, $space_beg, $space_sep, $space_end)
            = @{shift @field};
        if ($opt{color}) {                     # add highlights
            $field = highlight($field, @{shift @found});
            $value = highlight($value, @{shift @found});
        }
        $out .= $space_beg . $field . $space_sep . $value . $space_end;
    }
    # FIELD=VALUES(s) and QUERY. Insert fields into matching record.
    if (@found) {
        die "Can't insert data, QUERY matched more than one record\n"
            if $opt{write} and not $to_write;
        if ($to_write) {
            $out .= $to_write;
            $to_write = '';
        }
    }
}
die "Can't insert data, QUERY did not match any record\n"
    if $opt{write} and $to_write;

if ($opt{write} and $out) {
    $zdb->write($out);
} else {
    print $out;
}
exit !$out;

__END__

FIXME: See 'man pod2man' & 'man perlpodstyle' for a list of all sections that
should be included in a manpage.

=encoding utf8

=head1 NAME

zdb - Manipulate ZDB database


=head1 SYNOPSIS

=over 1

=item B<zdb> [I<OPTION>]... [B<-->] [I<QUERY>] [I<FIELD>B<=>I<VALUE>]... [I<FILE>]

=back


=head1 DESCRIPTION

B<zdb> is a utility for searching and manipulating human-readable text-based
database files (in ZDB format).

The I<QUERY> language has compact but expressive syntax (inspired by search
engines). You can use the following (in order of precedence) C<B<->> (minus)
for NOT, C<B<␣>> (space) for AND, and C<B<,>> for OR, C<B<(>I<...>B<)>>
(parentheses) for grouping, and C<I<FIELD>B<:>I<VALUE>> to specify which fields
to search. Unterminated parentheses/quotes do not cause errors, but are
automatically terminated for you. (See L</QUERIES> below.)

A I<FILE> of C<-> stands for standard input. When receiving input on standard
input, B<zdb> acts like a text filter (outputting the results to standard
output). When writing to file (that is, when I<FILE> is other than C<B<->>)
that file is updated (atomically) on success.

There are four different modes, depending on which of the I<QUERY> and/or
I<FIELD>B<=>I<VALUE> arguments are provided:

    ┌───────────────────┬───────────────────────────────┬────────────┐
    │ –                 │ Show database summary         │ read-only  │
    ├───────────────────┼───────────────────────────────┤            │
    │ QUERY             │ Show matching records         │            │
    ├───────────────────┼───────────────────────────────┼────────────┤
    │ QUERY FIELD=VALUE │ Add fields to matching record │ read-write │
    ├───────────────────┼───────────────────────────────┤            │
    │ FIELD=VALUE       │ Insert fields as new record   │            │
    └───────────────────┴───────────────────────────────┴────────────┘


=head1 OPTIONS

=over 7

=item B<-s>, B<--case-sensitive>

Perform case-sensitive search. This option overrides B<-S>/B<--smart-case>
(default) and B<-i>/B<--ignore-case>.

B<RATIONALE:> These option names (both long & short), are only used by a few of
the programs I've taken inspiration from: B<ag> (The Silver Searcher) and B<rg>
(ripgrep). However, the non-negated B<--case-sensitive> is clearer in intent
than negated B<-I>/B<--no-ignore-case> and B<--no-smart-case> (all of these
options have the same effect in B<zdb>).

=item B<--color>[B<=>I<WHEN>], B<--colour>[B<=>I<WHEN>] (default B<auto>)

When to highlight search matches in the output.

I<WHEN> may be one of the following (B<--paging> works the same):

=over 2

=item * B<always> (alias: B<yes>, B<force>) enables highlighting.

=item * B<never> (alias: B<no>, B<none>) disables highlighting.

=item * B<auto> (alias: B<tty>, B<if-tty>) enables highlighting only when
output is connected to a terminal. -- That is, it will be disabled if user has
piped the output to another command (S<C<| CMD>>) or directed it to a file
(S<C<< > FILE >>>), but otherwise it will be enabled.

=back

Using B<--color> (without I<WHEN>) means B<--color=always>; omitting the option
altogether means B<--color=auto> (also see B<-c> and B<-C>). (Option inspired
by B<grep>/B<ls>, borrowing the semantics from B<ls>, that is, using option
without arg means B<--color=always>, and I<WHEN> values B<yes>/B<force>,
B<no>/B<none> and B<tty>/B<if-tty> are only supported by B<ls>, not B<grep>.)

=item B<-c>, B<--color>, B<--colour>

Enable highlighting. Short for B<--color=always>. (Using B<--color> is the same
as B<--color>[B<=>I<WHEN>] without specifying the I<WHEN> argument.)

=item B<-C>, B<--no-color>, B<--no-colour>

Disable highlighting. Short for B<--color=never>. (Option B<--no-color> is
unique to B<zdb>.)

=item B<-e>I<QUERY>, B<--match=>I<QUERY>

Specify I<QUERY> explicitly. Useful when you don't want to put I<QUERY> as the
first argument, or in a situation where I<QUERY> might start with C<-> and be
interpreted as an option. (You can protect your I<QUERY> against this in other
ways too, for example by prefixing it with C<,> or using the B<--> option.)

If this option is repeated, the I<QUERY>(s) are OR:ed together. This means that
a record will be considered matching if one (or more) of the I<QUERY>(s) match.
(Short option inspired by B<grep>, B<sed>, B<awk>; long option by B<ack>.)

=item B<-h>, B<--help>

Output a usage message and exit.

=item B<--help-query>

Display a cheat sheet for the QUERY syntax. (See also L</QUERIES> below).

=item B<-i>, B<--ignore-case>

Ignore all case distinctions in I<QUERY>. This option overrides
B<-S>/B<--smart-case> (default) and B<-s>/B<--case-sensitive>.

B<RATIONALE:> These option names (both long & short), are used by the original
B<grep>, and is supported by B<all> the search programs I've looked at: B<ag>
(The Silver Searcher), B<git grep>, B<grep>, B<pt> (The Platinum Searcher),
B<rg> (ripgrep), B<sift>, and B<ucg> (UniversalCodeGrep).

=item B<-I>, B<--no-ignore-case>

The opposite of B<-i>/B<--ignore-case>. This is an alias for
B<-s>/B<--case-sensitive> (which is clearer in its meaning).

B<RATIONALE:> These option names (both long & short) exists for consistency
with grep B<grep>, it is actually an alias for B<-s>/B<--case-sensitive> (which
is clearer in meaning). The long option name is used by B<ack>, B<grep>, and
B<sift>, and the shortopt B<-I> is used by B<ack> and B<sift>.

=item B<-M>, B<--man>, B<--manual>

Display the B<zdb> manual page (using B<man>). The manpage accessible through
an option, (rather than using the normal B<man> command directly) since the
manpage is embedded inside the program itself (in the form of Perl POD
documentation), and does not exist as a separate manpage file. (TODO: See
L</Show manpage using B<$MANPAGER>>; Option B<-M>/B<--manual> inspired by
B<curl>, while B<--man> is inspired by the Perl tools B<ack> and B<prove>).

=item B<--pager=>I<CMD> (default B<pager>)

Specify a which command to use as a pager. (A pager is a program like B<more>
or B<less> which allows you to navigate through large output in a more
user-friendly way.) When a pager is used, the output of B<zdb> is piped to the
pager, and the standard output of the pager takes the place of B<zdb>'s
standard output. (Meaning that if a user pipes the output of B<zdb>, that pipe
will also pass through the pager, if it is enabled.)

The default command used is B<pager> (which in points to B<less> in many Linux
distros). The B<--pager> option overrides any B<$ZDBPAGER> or B<$PAGER>
environment variable setting. (See also L</ENVIRONMENT>: 'B<$ZDBPAGER>,
B<$PAGER>'; Option inspired by B<man>/B<bat>/B<delta>.)

B<RECOMMENDED:> Add the line C<export ZDBPAGER='less -RFXi'> to your shell's
init file. This will set the B<less> options B<-R> (allow color highlighting),
B<-F> (exit immediately if output fits on screen), B<-X> (disable screen
clearing on exit on some terminals), and B<-i> (turn off case-insensitivity
when searching in B<less>).

=item B<--paging>[B<=>I<WHEN>] (default B<auto>)

When to use a pager for the output.

I<WHEN> may be: B<auto>, B<always> or B<never> (and works the same as for
B<--color>). Using B<--paging> (without I<WHEN>) means B<--paging=always>; not
using B<--paging> means B<--paging=auto> (also see B<--pager=>I<CMD>, B<-p> and
B<-P>). (Option inspired by B<bat>/B<delta>.)

=item B<-p>, B<--paging>

Always use pager. Short for B<--paging=always>. (Using B<--paging> is the same
as B<--paging>[B<=>I<WHEN>] without specifying the I<WHEN> argument.)

=item B<-P>, B<--no-paging>

Never use pager. Short for B<--paging=never>. (Option inspired by B<bat>,
though B<--no-paging> is unique to B<zdb>.)

=item B<-S>, B<--smart-case> (default)

Make case-insensitive search, unless there are one or more uppercase characters
in I<QUERY>, in which case the whole query will be case-sensitive. This option
overrides B<-s>/B<--case-sensitive> and B<-i>/B<--ignore-case>.

B<RATIONALE:> The same long option name is used by B<ack>, B<ag> (The Silver
Searcher), B<pt> (The Platinum Searcher), B<rg> (ripgrep), B<sift>, and B<ucg>
(UniversalCodeGrep), and the shortopt is used by B<ack>, B<ag>, B<pt>, B<rg>.

=item B<--no-smart-case>

The opposite of B<-S>/B<--smart-case>. This is an alias for
B<-s>/B<--case-sensitive> (which is clearer in its meaning).

B<RATIONALE:> The long option name exists for consistency with B<ack>, and
B<sift> (while B<ucg> (UniversalCodeGrep) uses the similarly named
B<--nosmart-case>---an abomination not supported by B<zdb>). B<sift> uses the
shortopt B<-S> for this meaning, but B<zdb> follows the majority and uses B<-S>
to mean B<--smart-case>.

=item B<--test>

Run built-in unit tests. Tests are run using Perl's standard B<Test::More>
module. However, the module is loaded at runtime, rather than (the way it is
normally done) at compile time---This is to avoid impacting the load time of
normal use of the program (when the B<--test> option isn't used).

If B<--color> is enabled (which is the default), test will be filtered to show
a condensed, colorized form. In this form passing tests are not show in the
general output, and any remaining TODO tests will be listed at the end, if all
tests passed.

=item B<--version>

Output version information and exit.

=item B<-v>, B<--verbose>

Display a lot of output. This is mostly intended for debugging while developing
(so far anyway). Do not assume that this option will continue existing.

=back


=head1 QUERIES

B<zdb> uses a sloppy query language, inspired by web search engines. It strives
to be terse, intuitive, expressive, and forgiving. Unmatched parentheses and
quotes are fine (they will be terminated for you). Text in quotes is
interpreted literally (special characters/operators lose their meaning).

B<NOTE:> The shell processes its quotes before the arguments are ever seen by
B<zdb>. This means that you have to quote your quotes! It's usually most
convenient to put single quotes around your whole query (these outer quotes
eaten by the shell) and then use double quotes inside that if you need it. For
example:

    zdb 'name:("crew member",crewmember)' -fklingon.zdb

Query is matched word-by-word (C<B<cat>> does not match "cats"). An (unquoted)
asterisk (B<*>) may be used to match zero or more letters: C<B<cat*>> matches
both "cat" and "cats" and "catwoman"; C<B<*fix>> matches "fix", "prefix", and
"suffix". An (unquoted) underscore (B<_>) can be used to match one or more
whitespace characters (including newlines).

Search is case-insensitive by default, except if I<QUERY> contains any
uppercase letters, in which case the entire I<QUERY> is read as case-sensitive.
(Options B<-S>/B<--smart-case> [default], B<-s>/B<--case-sensitive> and
B<-i>/B<--ignore-case> change this behavior.)


=head2 Logic operators

The following operators are also supported:

    ┌──────────────┬──────────────┐
    │  Character   │  Used For    │  From the most tightly binding, to the
    ├──────────────┼──────────────┤  least binding.
    │  :  (colon)  │  prefix      │
    ├──────────────┼──────────────┤  Thus: '-a:b, -c d' = '(-(a:b)), (-c d)'.
    │  =  (equal)  │  whole field │
    ├──────────────┼──────────────┤
    │  -  (minus)  │  not         │
    ├──────────────┼──────────────┤
    │  ␣  (space)  │  and         │
    ├──────────────┼──────────────┤
    │  ,  (comma)  │  or          │
    ├──────────────┼──────────────┤  ¹ Any missing parentheses are automati-
    │ (…) (parens) │  grouping¹   │    cally added at start/end of QUERY.
    └──────────────┴──────────────┘


=head2 Field prefixes

To only search a specific field, a field name prefix (I<FIELD>B<:>I<VALUE>) may
be used. (For example, C<name:anderson> will find all occurrences of 'anderson'
in the 'name' field.) The full syntax is:

[I<FIELD>B<:>]I<VALUE>[B<:>I<VALUE>]...

Where no C<I<FIELD>B<:>> means the same as C<B<*:>…>.

Both I<FIELD> and I<VALUE> may be arbitrarily complex Boolean expressions.
Since B<:> is so tightly binding, however, parentheses are required around each
I<FIELD> and I<VALUE> containing a complex expression.
(C<(name,alias):anderson> will find 'anderson' in either 'name' or 'alias'.)

When multiple I<VALUE>s are chained together (…B<:>I<VALUE>B<:>I<VALUE>),
matching of subsequent I<VALUE> are only attempted in fields that have matched
the previous I<VALUE>(s) in the chain. (Thus, C<name:magnus:anderson> will
match all 'name' fields which contain B<both> 'magnus' and 'anderson', and
C<(name,alias):magnus:anderson> will match 'name' or 'alias' fields that
contain B<both> 'magnus' and 'anderson' B<in the same field>.)

I<FIELD:> (without a value) will match all fields with the specified name
(regardless of value. (C<(name,alias):> will match all records that contain
either a field called 'name' or 'alias'.)


=head2 Quoting

    ┌──────────────────┬───────────────┐
    │  Character       │ Used For      │
    ├──────────────────┼───────────────┤
    │ "…" (quotes)     │ quoting       │
    ├──────────────────┼───────────────┤
    │ ""  (two quotes) │ literal quote │ FIXME: NOT YET IMPLEMENTED
    ├──────────────────┼───────────────┤
    │ *   (asterisk)   │ word char     │
    ├──────────────────┼───────────────┤
    │ _   (underscore) │ whitespace    │
    └──────────────────┴───────────────┘

Characters in double quotes are always matched as-is, so to search for special
characters (parentheses, an asterisk, or spaces) put them in double quotes.
(C<phaser pistol> finds records containing both of the words 'phaser' and
'pistol' in either order, while C<"phaser pistol"> will find all occurrences of
the phrase "phaser pistol".) Note also, that only B<double> quotes (B<">) have
a special meaning, single quotes (B<'>) are taken literally. (C<d'armond> will
find all occurrences of said name.)

Quotes can begin and end anywhere, and so to search for a phrase where one word
may vary use something like B<C<"the "*" of">>. The only exception to this is
that two quotes in a row (regardless of whether it occurs inside or outside of
a quote) will match a literal quote.

One or more whitespace characters can be matched by an (unquoted) C<B<_>>. This
will match across a line ending (within the same field), so that
C<phaser_pistol> will match even if there's a newline between the words (while
C<"phase pistol"> will match only if the words are separated by a single space).


=head1 RETURN VALUE

FIXME


=head1 DIAGNOSTICS

FIXME: Add missing error messages

=over 4

=item Can't exec 'man': I<REASON>

This resulted from C<< zdb --manual >> not being able to find or execute the
B<man> viewer needed to show the manpage. On my Linux machine the B<man> tool
is installed by default (and is available in the Debian B<man-db> package). If
worst comes to worst, the documentation is viewable (in the fairly readable
'POD' format) by looking at the program 'binary' as well.

=item Can't exec 'pod2man': I<REASON>

=item Command 'pod2man' failed: I<REASON>

This resulted from C<< zdb --manual >> not being able to find or execute the
Perl tool B<pod2man>, which is used to generate the manpage. This tool comes
with the standard Perl installation, but the documentation can also be found
inside the B<zdb> source code itself (and is fairly readable).

=back


=head1 TAB COMPLETION

This is how to set up tab completion for B<zdb>. I've only listed how to do it
for B<zsh> since that's the shell I'm using. Feel free to contribute
suggestions for other shells!

=head2 Tab completion for Zsh

To get autocompletion of B<zdb> options in B<zsh>, create a file called F<_zdb>
(with an initial '_'!) in the whatever directory your instance of B<zsh> keeps
its autocompletion functions.

    #compdef zdb
    _arguments \
      '--color=[When to use colors]:WHEN:(always auto never)' \
      '--paging=[When to use paging]:WHEN:(always auto never)' \
      '*: :_gnu_generic'

This directory will be one of the directories in the B<$FPATH> environment
variable, to list them all in an easily readable fashion, use:

    echo ${(F)fpath}

This autocompletion function should actually allow any arbitrary command (with
options) to be entered as an argument for B<--pager>, and I should also like a
little query language cheatsheet to be displayed when tab is pressed in a query
position (that is, as the first arg, or as an argument to B<--e>/B<--match>.


=head1 EXAMPLES

=head2 'Self-searchable' ZDB databases

One may create 'self-searchable' ZDB database, which can be invoked by using
the database file itself as a command. For example, my Klingon dictionary is
called F<klingon.zdb>, and to search for the word 'phaser' I can simply write:

     ./klingon.zdb phaser

To achieve this, a (relatively complicated) shebang (C<#!>) line needs to be
added to the top of the database file. This shebang invokes B<zdb>, and
rearranges the arguments so that name of the database file occurs last in the
command. The following B<shebang> can be used:

    #!/usr/bin/env -S sh -c 'exec zdb "$@" "$0"'

For the above to work B<zdb> needs to be somewhere in your B<$PATH>.

As the shebang command is invoked, the first argument (B<$0>) is the name of
the B<zdb> database file (in which the shebang line is found). If we did not
invoke B<sh> to flip the arguments around, B<$0> would have been given as the
first argument (which would've caused B<zdb> to throw an error).

The database file also needs to be executable for this to work.

    chmod +x ZDBFILE

Now, 'executing' the database will pass all arguments given as-is to B<zdb>,
with the name of the database file tucked onto the end of the command line.


=head1 ENVIRONMENT

=over 7

=item B<$ZDBPAGER>,  B<$PAGER> (fallback value: B<pager>)

Defines what command to use as pager for the output. B<$ZDBPAGER> overrides
B<$PAGER>, both of which can be overridden by the B<--pager=>I<CMD> option.

The default command used is B<pager> (which in points to B<less> in many Linux
distros).

B<$ZDBPAGER> may contain any command or command pipeline. But it is inadvisable
to put a command pipeline in B<$PAGER>, as, for example B<man> (which also
reads this variable) does not allow it.

B<RECOMMENDED:> Add the line C<export ZDBPAGER='less -RFXi'> to your shell's
init file. This will set the B<less> options B<-R> (allow color highlighting),
B<-F> (exit immediately if output fits on screen), B<-X> (disable screen
clearing on exit on some terminals), and B<-i> (turn off case-insensitivity
when searching in B<less>).

=back


=head1 FILES

B<zdb> can act either as a text filter, with a B<zdb> file piped in on standard
input (with either no file give on the command line, or I<FILE> specified as
C<B<->>), in which case output is written to standard output.

If an input I<FILE> is given on the command line, that file is updated
in-place. This is done using atomic updates (output is written to a tempfile,
called C<B<.>I<FILE>B<.tmp>>, and after a successful write, it is renamed to
replace the old file). A lockfile is also used, and B<zdb> will refuse to
modify a database that is currently being modified by another B<zdb> instance.


=head1 CAVEATS

FIXME


=head1 RESTRICTIONS

Only two different colors are used when highlighting found matches. This means
that if multiple search terms overlap, the color intensity will only ever
accurately reflect one or two overlapping matches. The color will not increase
beyond that. This is not expected to change in the future. (As overlapping
matches are presumably pretty rare anyways.)


=head1 AUTHOR

Copyright (C) 1998--2025 zrajm <zrajm@klingonska.org>.


=head1 HISTORY

B<v0.0.1> - Primitive initial functionality. Output a ZDB file (given a ZDB
file on standard input), and split the file into records internally while
preserving whitespace between records (and at the beginning & ending of file).
(2025-11-11 00:51--06:50, 15:26--21:32; 2025-11-12 00:04--02:20)

B<v0.1.0> - Defined internal query format, and internal data format. File now
loads into the new format loading. Implemented search (using a simple hardcoded
query). Added highlighting of search result (including overlapping matches).
(2025-11-11 15:26--16:11, 19:45--21:31; 2025-11-12 00:04--03:28, 05:02--07:12;
2025-11-14 01:03--06:30, 18:10--11:42)

B<v0.1.1> - Documented internals somewhat. (2025-11-14 11:42--12:22)

B<v0.2.0> - Added B<--pager> and B<--manpage> options. Pager defaults to
whatever is specified in the $PAGER environment variable (defaulting to
B<less>). B<--manpage> option shows simple documentation (not yet manpage
formatted, but its *something*). Also removed the command line options
B<--help-internals> and B<--todo> as this info is now part of the manpage
instead. (2025-11-15 15:33--17:06)

B<v0.3.0> - Pager now defaults to B<pager> (instead of B<less>). Better
suppression of pager (or, in the case of B<--manpage>, manpager) when there are
errors. Extensive rewrite of docs. (2025-11-16 00:06--04:39, 23:18--02:27;
2025-11-17 04:29--08:10, 14:13--17:07)

B<v0.3.1> - Moved query parsing and matching into Query module. (2025-11-17,
18:53--19:23)

B<v0.3.2> - Now gets QUERY from command line arguments. Very basic, all
arguments are simply AND:ed, and each pattern is expected to match a whole word
(with no wildcards or anything). (2025-11-18 19:26--19:39)

B<v0.3.3> - Added B<--paging> option. (2025-11-18 19:39--21:21)

B<v0.3.4> - Tested/verified and documented the B<$PAGER> and B<--pager=>I<CMD>
capabilities. (Yes, Perl allows more complex commands to be used.) (2025-11-18
21:21--21:42)

B<v0.4.0> - Added B<ZDBPAGER> for B<zdb>-specific pager defaults. (2025-11-19
00:04--01:01)

B<v0.4.1> - Moved unit tests into Query module. (2025-11-19 02:28--02:41)

B<v0.4.2> - Now use Test::More for unit tests in Query module. (2025-11-19
02:41--03:20)

B<v0.4.3> - Updated manpage. Added description of how to use B<zdb> as a
shebang. Made sure manpage includes all required headlines. Added notes on
L</FILES> and L</RESTRICTIONS>. (2025-11-20 07:31--09:08)

B<v0.4.4> - Updated manpage with ideas for future. (2025-11-23 11:18--13:44)

B<v0.5.0> - Renamed B<--manpage> option to B<--manual> (and added the short
option B<-M>). The new option names are the same as those used by the B<curl>
command. Unfortunately, almost no other commands seem to provide a flag to show
their B<man> page, so it isn't very easy to find an intuitive option name to
use. :( (2025-11-23 13:44--13:58)

B<v0.5.1> - Expanded manpage. Improved chapters DESCRIPTION, QUERIES
(subchapters 'Logic Operators', 'Field Prefixes' and 'Quoting'). Added and
clarified a buncha stuff on the L</FUTURE> wishlist. (2025-11-25 08:49--11:29)

B<v0.5.2> - Moved C<< END {} >> block to after info variables. (2025-11-25
12:31--12:36)

B<v0.6.0> - Added B<-e>/B<--match> option and removed B<-f>/B<--file> option.
B<--file> was used to specify a database input file (mentioned as being
inspired by B<grep>'s option of the same name) but B<grep> actually uses that
option to specify a file of B<match patterns>, not data! This update brings the
options in line with how B<grep>, B<sed> and B<awk> (actually) works.
(2025-11-25 02:14--04:57, 11:37--12:56, 17:29--18:01; 2025-11-26 15:08--15:59)

B<v0.6.1> - Support for '-' argument. QUERY argument now mandatory (until
implementing L</No QUERY = Show database status>). Also updated usage string to
reflect this. (2025-11-26 15:59--17:37)

B<v0.6.2> - Documentation proofreading & fixes. (2025-11-26 18:46--18:59)

B<v0.6.3> - Additional manpage spellfixes. (2025-11-26 18:59--19:20)

B<v0.6.4> - Corrected B</bin/env> -> B</usr/bin/env>. (2025-11-26 19:20--19:23)

B<v0.6.5> - Added note about hierarchical fields to L</FUTURE>. (2025-11-29
00:13--00:25)

B<v0.7.0> - Added some preliminary query parsing and started working on tests
for the same. Code is currently in a non-functional state, as the PARSING is
approaching done, but generating the query function from the parse tree remains
to do be done. Also, the internal representation of the parse tree will most
likely change. (2025-11-28 18:30--13:45)

B<v0.7.1> - Added tests for C<Query::_parse()>, and got the 'bottomless' stack
feature to work (meaning that unmatched ')' in the syntax query now works too).
(2025-11-30 13:20--14:11, 20:20--22:12; 2025-12-01 08:16--10:40, 11:21--13:50,
15:50--16:48, 23:03--23:34)

B<v0.7.2> - Test callback function now declared using C<sub {}>. (2025-12-01
23:42--23:50)

B<v0.7.3> - Remove use of 'plain' object property when parsing (& testing)
query. (Now use only the '_word' property which is split into individual
chars.) (2025-12-01 23:54--23:57)

B<v0.7.4> - Very minor cleanup. (2025-12-02 08:43--08:56)

B<v0.7.5> - Moved some parsing logic into Query::Stack. (2025-12-02
09:15--09:52)

B<v0.7.6> - Made finite state machine shorter/more readable. Added a test for
double parentheses. (2025-12-02 10:02--10:06)

B<v0.7.7> - Simplify query during parsing by trimming empty words. (2025-12-02
11:34--13:44)

B<v0.7.8> - BUGFIX: Honor quotes in query + test cases for that + other small
fixes. (2025-12-02 13:51--14:20)

B<v0.7.9> - Removed 'or' field from stack items, and added 'type' = 'word' for
word items (now relying on 'type' = 'and', 'or', 'nor' or 'word'). (2025-12-02
16:05--17:25)

B<v0.7.10> - Changed internal format. Search words are now also (just like
parentheses) stored as arrayrefs, where first element is a metadata hashref.
(2025-12-02 17:58--18:42, 21:12--22:30)

B<v0.7.11> - Renamed a B<Query::Stack> function. Documented the future of the
query parsing. (2025-12-02 22:38--22:58)

B<v0.7.12> - Removed unused query cleanup function. (2025-12-03 08:04--08:12)

B<v0.7.13> - Now removes empty terms in QUERY during parsing. This continually
cleans up both empty search words (which are inserted as part of the query
parsing itself) and empty parentheses as the query is being parsed. (2025-12-03
08:12--09:20)

B<v0.7.14> - Slightly different syntax for unit tests involving 'not' (B<->)
and 'field' (B<=>) prefixes. (2025-12-03 09:45--10:05)

B<v0.7.15> - Slight change in debug output. No longer using 'nor' for negative
OR parentheses, but instead prefixing parentheses B<-> and B<=> for negated and
field matching. (2025-12-03 10:14--11:40)

B<v0.7.16> - Now removes any parenthesis in QUERY that wrap a single term. Term
inside is kept, and the 'not' and 'field' attributes of the removed parenthesis
and the term are combined. (2025-12-03 17:31--21:54)

B<v0.7.17> - Prettier B<--test> output. (2025-12-03 23:46--00:51)

B<v0.7.18> - Added a slew of unit tests. Unit tests were taken from my online
Swedish Sign Language dictionary, which implement a very similar (sloppy) query
language (L<https://zrajm.org/teckentranskription/lexicon-tests.html>).
(2025-12-04 07:50--12:14)

B<v0.7.19> - Implemented query B<Query::_normalize()>, which moves query
prefixes C<B<->> and C<B<=>> to the leaf nodes of the query, applying De
Morgan's Law. This makes sure that match highlighting works, by no query term
negated more than once. Also added the tests required to test the new function,
and adapted the test functions for this. (2025-12-04 00:56--01:49,
17:24--17:51, 18:06--18:23; 2025-12-05 09:05--12:39)

B<v0.7.20> - Prettified this L</HISTORY> section. (2025-12-05 12:42--13:16)

B<v0.7.21> - Implemented rudimentary B<Query::_compile()> function. QUERY is
now used for actual searching of database. (2025-12-05 14:15--15:56; 2025-12-06
02:18--03:47)

B<v0.7.22> - Cleanup of unused code. (2025-12-06 04:38--04:50)

B<v0.7.23> - Minor change in argument parsing. (2025-12-07 20:44--21:01)

B<v0.7.24> - QUERY prefixes C<B<->> and C<B<=>> now work in search. (2025-12-07
21:01--22:19)

B<v0.7.25> - Added query compilation 'lang' argument for specifying which
functions to use for AND/OR and string matching in the finalized query. The
purpose of these is to be able to provide alternate functions, e.g. for
producing highlighted output, for dumping the query in cleaned up form.
(2025-12-07 22:19--22:48)

B<v0.7.26> - Renamed query type C<word> to C<atom>. (2025-12-07 22:48--23:06)

B<v0.7.27> - Minor docs update on internal structure. (2025-12-07 23:06--23:21)

B<v0.7.28> - Simplified B<Query::_compile()>. (2025-12-07 23:23--23:31)

B<v0.7.29> - Implemented query dump output. (2025-12-07 23:33--00:16)

B<v0.7.30> - Command exit code was always 255, this fixes that. (2025-12-09
13:20--13:34)

B<v0.7.31> - Added options B<--no-color> and B<--no-paging> and updated
relevant documentation. (2025-12-11 20:38--21:10)

B<v0.8.0> - Added highlighting of matching strings, and also added unit tests
for all the new functions related to this, as well unit tests for the older
matching logic. (2025-12-08 01:20--02:16, 14:15--17:03, 17:49--18:51,
2025-12-09 12:27--13:00, 15:09--15:29, 20:24--00:20 2025-12-10 14:27--16:29,
17:05--19:23 2025-12-11 14:10--14:48, 16:13--17:04, 18:57--19:33, 2025-12-12
22:01--22:24, 2025-12-13 02:39--03:07, 12:06--12:39, 12:52--13:11, 2025-12-14
00:58--01:54, 02:19--04:01)

B<v0.8.1> - Search now highlighting disabled now works (again). This involved
making the _matcher() functions return true/false even in list context. Updated
unit tests accordingly. (2025-12-14 04:01--04:15, 18:29--18:58, 19:31--20:14)

B<v0.8.2> - Added option B<--man> as an alias for B<--manual>. (2025-12-14
23:46--23:59)

B<v0.8.3> - Updated docs. (2025-12-15 00:01--02:56)

B<v0.8.4> - Researched and added docs on how install tab completions for B<zdb>
in B<zsh>, plus some other minor improvements to the L</FUTURE> section.
(2025-12-15 18:14--20:10, 21:18-21:25)

B<v0.8.5> - Added L</MILESTONES> to the docs & restructured the L</FUTURE>
section somewhat. (2025-12-15 21:28--22:04)

B<v0.8.6> - Added writing of new fields to a matching record. (2025-12-16
23:36--00:03, 01:16--02:41)

B<v0.8.7> - Added creation of new B<records> when giving I<FIELD>B<=>I<VALUE>
without I<QUERY> on the command line. (2025-12-16 02:51--03:32, 06:21--06:37)

B<0.8.8> - Wrote syntax hiliting files for Emacs (B<zdb-mode.el>) and B<bat>
(B<ZDB.sublime-syntax>) and created a README with installation instructions,
also added some notes to the docs. (2025-12-18 07:14--15:30)

B<0.8.9> - Researched terminal feature 'back color erase' (B<bce>). In the end,
no action needed. (2025-12-21 20:17--01:21)

B<0.8.10> - Highlighting in three different levels. (2025-12-22 04:29--04:40)

B<0.8.11> - BUGFIX: Uninitialized variable caused warning when there were no
matches. (2025-12-22 04:49--04:52)

B<0.8.12> - Now sets exit status to 1 if there's no match, 0 otherwise.
(2025-12-22 04:57--05:04)

B<0.8.13> - Added search wildcards B<*> *matching zero or more word characters)
and B<_> (matching one or more whitespace characters). (2025-12-22
05:23--07:06)

B<0.8.14> - Implemented options B<-s>/B<--case-sensitive>,
B<-i>/B<--ignore-case> and B<-S>/B<--smart-case> for controlling
case-sensitivity of matching. (2025-12-22 07:08--10:34, 19:49--20:32,
21:26--04:15, 2025-12-25 22:27--23:48)

B<0.8.15> - Improve B<--test> output. Test output is now run through a filter,
that removes passing, only showing fails and unexpected passes in TODO blocks.
If all tests passed, a summary of remaining TODO(s) is also shown. Tests also
obey color setting---the original test output is show if color output is
disabled with B<--no-color>. (2025-12-24 19:12--03:09, 2025-12-26 00:02--00:44)

B<0.8.16> - Added lockfile and (atomic) file updates. (2025-12-26 00:45--08:41)


=head1 COPYRIGHT AND LICENSE

Copyright 2025, zrajm L<zrajm@klingonska.org>. ZDB file format copyright
1998--2025 by zrajm and Klingonska Akademien (Uppsala, Sweden).
L<https://klingonska.org>.

License GPLv2: GNU General Public License version 2 or later
L<https://gnu.org/licenses/gpl-2.0.html>. This is free software: you are free
to change and redistribute it. There is NO WARRANTY, to the extent permitted by
law. (See also C<zdb --version>.)


=head1 SEE ALSO

B<zdb> is partly inspired by GNU B<recutils>. -- When I first heard about
B<recutils> I was delighted to find that its file format it is strikingly
similar to the plain-text 'database' format I've used for my Klingon dictionary
since the very end of the last century (see
L<https://klingonska.org/dict/dict.zdb>). I was to a large degree inspired by
the shortcomings of B<recutils> -- its query language is verbose and pretty
inflexible (I felt I could do better!), and B<recutils> does not highlight
matches.

Hence, this little project! :)


=head1 INTERNALS

=head2 Internal query format

The inputted query (or queries, if multiple B<-e>/B<--match=>I<QUERY> options
are given) are parsed, normalized and compiled.

During query parsing a query expression given on the command line is turned
into a tree structure. Search words/phrases correspond to the leaf nodes in
this tree and are called atoms (that's where the actual string matching is
done) and parenthesis in the query correspond to the intermediate nodes (which
have a type of either AND or OR). The query parser also adds additional
intermediate nodes, where needed to resolve Boolean operator precedence.

After parsing the query, the resulting query tree is normalized. This turns the
query into Negation Normal Form, by moving any use of negation (C<->), and
exact field match (C<=>) prefixes out into the leaf nodes of the query. These
operations are thus only performed once during a search. (That is, search
query like C<-(-x y)> is internally turned into C<(x,-y)> before matching is
attempted).---This is allows doubly negated terms to be highlighted in the
search result, and simplifies traversal of the intermediate nodes.

Finally the query is compiled into a function which, when passed the contents
of a database record, determines whether that particular record matches the
query or not. (When match highlighting is enabled, it also returns the
character offsets used for the highlighting.)


=head2 Internal database representation

In the main loop C<read_record()> is called over and over until the entire file
has been read. (And the query is used in turn for each record to determine
whether or not it matches.) C<read_record()> returns two values, the first of
which is a string, and the second a list-of-lists. The initial string as all
whitespace leading up to the record, and the list of list contain a listref for
each field. The syntax for these listrefs are:

    [FIELD, VALUE, BEG_SPACE, SEP_SPACE, END_SPACE]

The first two being the field name and value, and the last three are all
whitespaces, the B<BEG_SPACE> found just before B<FIELD>, B<SEP_SPACE> is the
separator between B<FIELD> and B<VALUE>, and B<END_SPACE> comes after B<VALUE>.

In the ZDB format B<BEG_SPACE> is always an empty string, and B<END_SPACE>
always a newline. (These are mostly for future-proofing, and having the option
of supporting other data formats in the future.) B<SEP_SPACE> may vary
depending on the amount of whitespace found between B<FIELD> and B<VALUE>.


=head2 Rejected ideas (for now)

=over 4

=item Handling of terminal feature 'back color erase' (B<bce>)

After some research I don't think this issue B<needs> addressing. That
terminals B<don't> extend the end-of-line background color to the right margin
is the right thing to do in my eyes. Keeping it here for future reference.

B<$GREP_COLORS> contain a feature C<B<ne>> which for handling the terminal
feature 'back color erase' (B<bce>). Should B<zdb> also do this? When is it
relevant?

The (often quite opinionated) developer of Kitty (the terminal I'm currently
using) has described B<bce> as an anti-feature, saying it won't added to
Kitty---Which might be the correct decision for all I know (see
L<https://github.com/kovidgoyal/kitty/discussions/3873#discussioncomment-15138580>).

The following code outputs a text 30 times, and if it hits the bottom of your
terminal window, then, on B<some> terminal & terminal multiplexers, you'll see
the background color is set and a newline is printed you'll see the red
background stretch out in a lite towards the right edge of the window (looking
quite horrible)---I B<think> this in the B<bce> feature in action.

    clear; for x ({1..30}) { echo $'def \e[41m red \n red \e[49m def' }

Red background lines appear on: Linux console, B<qterminal> (which uses
B<TERM=xterm>) and inside B<tmux> (regardless of which terminal it runs on).
But not in B<kitty> or B<screen>.

However, looking at the terminfo descriptions with:

    infocmp $TERM | grep bce

Does not correlate with the above behavior. If B<$TERM> is B<linux> (=linux
console) and B<xterm> claim to support B<bce>, while B<tmux>, B<screen> and
B<kitty> does not (in all instances B<TERM-256color> give the same result as
plain as without the suffix B<-256-color>).

It seems to me that what the B<$GREP_COLORS> B<ne> feature is trying to
achieve, is to consistently extend any background color that is in effect at
the end of the line all the way out to the right margin (the aesthetics of this
isn't very pleasing to my eye, but I figure that's what it's going for).

Trying this out on several different terminals with the command:

    printf '\e[41m\e[Kfoobar\n\e[m'

Yields the following result: The end-of-line background is extended to the
right on: B<kitty>, B<linux> (= the Linux console), B<qterminal> and in B<tmux>
(on all terminals), but not in B<screen> (in any terminal).

=back


=head1 MILESTONES

=head2 Version 1.0

B<Write to file> -- Adding fields to existing records; adding & deleting
records. Should work in both 'filter mode' (input on STDIN, output on STDOUT)
and as (atomic) writes to specified file. (Add new stuff at the end.)

B<Case matching> -- Matching should obey case options B<--ignore-case> and
B<--smart-case>. (Smart case being the default.)

B<Fix query bugs> -- Missing leading parenthesis must work. Don't search
comments (by default).

=head2 Version 1.1

B<%fields> in database to specify sort order, and defining allowed field value
content.

B<Undo diffs> -- Updating database (when writing file) should write the
modifications made to disk as diffs.

Moar?


=head1 FUTURE

Below are some planned future features. (Some section has separate FIXME
comments that will be fixed in the future as well.)

=head2 Query improvements

=over 4

=item Better word border detection

When a word in a query begins/ends in a non-alphanumeric character, it
shouldn't be expected to be at a word border (regex B<\b...\b>).

=item Option to enable/disable diacritics

Should make 'a' match 'ä'. (Related to/influenced by 'Field locale settings'?)

=item B<BUG:> Fix implicit leading parentheses

Applies mostly to missing B<(> at beginning of query string, but also (to lesser
degree) to missing B<)> at the end.---See failing unit tests.

=item Unwrap parentheses with same AND/OR as parent

Nice-to-have, but not really B<important> in any way (if implemented queries
will become very slightly faster, outputted cleaned up queries will look
prettier.)

=item Don't search comments by default

Option to enable/disable searching comments. By default comments should not be
searched.

=item Multiple I<QUERY>s(?)

When providing multiple I<QUERY>s on the command line (with multiple
B<-e>/B<--match=>I<QUERY>) each query should be parsed on its own, and
processed with whatever case options where valid at that point in the command
line. Just like multiple B<-e>I<PATTERN> expressions in B<grep> the queries
should be OR:ed together.

=item Match record sets

There should be a way to match only entries in a specified record set. Maybe
prefix B<%rec:…>?

=item Match numbers

Use C<[…]> to match numbers. The brackets themselves will match a number in the
text (a regex like C<< [+-]?(\d*\.)?\d+ >>, though that doesn't cover numbers
in scientific notation). After matching the mathematical expression inside the
brackets will be applied as well, so that an empty bracket C<[]> matches any
number; C<[E<lt>100]> matches any number below 100; C<[1990..2020]> will match
a number between 1990 and 2020 (inclusive), and C<[=42]> matches the number 42.

=item Match dates

How to solve date matching? I would like something similar to the above number
matching, but that allows for dates. (Internally translating stuff to epoch
time and comparing it that way.) Ideally the date comparison should extract and
parse date in the locale specified for the field (and be able to extract all
kinds of date formats, from 'December 1, 2020' to '2020-12-01').

=item Argument to clean up query(?)

It can sometimes be hard to know how exactly B<zdb> will interpret your query.
Using this argument should show a cleaned up version of QUERY (suppressing
search). -- Should this also simplify Boolean logic? Or just show what the
query looks like after the shell has stripped its quoting? Both?

=back

=head2 Highlighting

=over 4

=item Add unit tests for highlight()

=item Terminfo/termcap

Should look at terminfo (or whatever is needed) to determine what highlight to
use.

=item Implement B<$NO_COLOR>

If B<$NO_COLOR> environment variable is set, disable colors by default. After
implementing this, also submit a pull request to this project
L<https://no-color.org/>.

=item Highlight color config

User should be able to choose highlight color. (Should we maybe take colors
from B<$GREP_COLORS> environment variable? And make it possible to override
with our own B<ZDBCOLORS>?)

=item Option to user pager's highlighting

Add option to, instead of highlighting the output, use pager options for the
highlighting. When using B<less> as a pager, for example, this would involve
invoking it with the B<--use-backslash> and B<+/>I<REGEX> options.

This would have the drawback that overlapping searches would not be marked, but
the benefit that the user would be able to easily navigate back and forth
between the matches inside the pager.

Maybe B<delta> uses the option B<--navigate> to: "Activate diff navigation. Use
'n' to jump forwards and 'N' to jump backwards."

=item Syntax Highlighting

Syntax highlighting, on top of the search highlight. This should use different
colors for comments (when shown), field names, special field names (beginning
with B<%>) and field values.

=back

=head2 Unit tests

=over 4

=item Speed up program load time?

Is compilation of tests slowing B<zdb> down? If so, there is some module which
puts selected code after C<__DATA__> block. Use that to speed things up?

=back

=head2 Database verification and format

=over 4

=item Field locale settings

These locale settings should handle how characters match and are sorted. For
example, in an English locale one would expect searching for 'a' to also match
any 'a' with arbitrary diacritics and or case. While in Swedish, 'a' and 'ä'
would count as separate letters (while 'e' and 'é' would not). In a
(hypothetical) Klingon locale, 'q' and 'Q' would count differently.

One should be able to have different locale settings for different fields. This
would kinda complicate queries somewhat, with different regexes having to be
used for the exact same string depending on locale.

It seems like one cannot interrogate the locale settings to find character
equivalents. So, maybe adding an B<%alphabet> field to the settings (connected
to the data type of a field?) which would list all the characters of that
alphabet. Any accented characters occurring in that set (such as Swedish åäö)
should be treated as different from the other characters, while any other
accented character should match the corresponding unaccented one. (That is,
decompose all characters (with C<NFD()>) and then precompose all accented
characters from the B<%alphabet> set (with C<NFC()>).

=item Automatic linebreaking

There should maybe be an option to produce automatic linebreaks in fields? How
about fields containing explicit newlines? (Like an address, or poetry?)

=item Add record sets B<%rec> (and B<%doc>)

Implement B<recutils> 'record set' field B<%rec>. Record set name should
probably use the same limitations (and recommendations) as B<recutils> do (see
'Naming Record Types' in the B<recutils> manual).

=item Record and field sorting

Sorting, being a slow operation, should never be performed on the whole
dictionary unless explicitly requested. (Using a B<--sort> option, perhaps?)
However, when inserting records or fields, the sort order should be respected,
and the new record/field should be inserted late as possible in the record set
or record.

B<Record sort:> In B<recutils> the B<%sort> option is used to define how
records are sorted relative to each other in a record set. For example,
B<recutils> uses B<S<%sort: author year>> to specify should be sorted primarily
by the content of the B<author> field, and secondarily by B<year>.

B<Field sort:> B<recutils> has no way of sorting fields within a record. So
will have to be invented here. Sorting should be stable, so that if there are
interleaved fields of different names, the internal order between fields of the
same name should be retained (but the different field names should no longer be
interleaved) after sorting.

=item Field types and field verification

B<recutils> uses B<%type> and B<%typedef> for this purpose. Also the fields
B<%mandatory>, B<%allowed>, B<%prohibit>, B<%unique> and B<%constraint>. In
normal operation B<zdb> should give an error if user tries to add (or remove)
records or fields that break what's allowed. A B<--force> option should allow
one to make breaking changes. But verification of whole database might be too
slow to perform for each modification. (Maybe add B<--verify> option or
similar for checking the whole database?)

=back

=head2 Command behavior

=over 4

=item Warn when I<QUERY> is empty?

=item Suppression of lengthy output

It would be convenient to be able to suppress lengthy output and/or disable
pager for short output (shorter than a screenful?).

=item Show manpage using B<$MANPAGER>

The B<--manual> option should use the B<$MANPAGER> environment variable to
determine how to display its manpage. Currently B<man -l -> is used to display
the manpage, but to allow for B<$MANPAGER> the manpage should be written to
tempfile and the manpager should be invoked as C<$MANPAGE FILE> (where I<FILE>
is a path beginning with '.' or '/').

=item Add B<+> option

This option is passed on to the pager. This can be used with the B<--man>
option to immediately go to a specified section (for example using
C<B<+'/FUTURE'>>) but can also be used in ordinary searches.

=item No QUERY = Show database status

Giving an input file, but no I<QUERY> or I<FIELD>B<=>I<VALUE> pairs should give
a summary of the input file. Summary should include B<%rec> and B<%doc> fields
for each record set, and there should also be a summary of the fields usage
used for each set. For example we could see something like the following to
indicate that the field 'tlh' occurs once in 3033 records, while the field
'cite' occurs zero times in 2627 records, once in 320 records etc.

    %rec	words
    %doc	Klingonska Akademien's Klingon Dictionary
    tlh		1 -- 1:3033
    ...
    cite	0..5,7 -- 0:2627 1:320 2:58 3:18 4:4 5:4 7:3
    ...

Should also have a look at what the B<recinf> command outputs for additional
inspiration.

Also update usage to show that QUERY argument is optional! (Meaning that we
also only need one usage line instead of two.)

    zdb [OPTION]... [--] [QUERY] [FIELD=VALUE]... [FILE]

=back

=head2 Undo

As a database is updated, patches should be generated and saved into a
directory next to the database. (Similar to how tempfiles are stored.) So,
maybe create a directory 'B<.>I<FILE>B<.undo>' (or 'B<.>I<FILE>B<.diff>') and
then, inside that directory create patches called
I<YYYYMMDDB<_>HHMMSS>B<.diff>. This way, any of the patches can be reapplied to
undo that change.---Or, possibly, diffs could instead be added to a B<.zip>
file (or other archive).

=head2 Compression

Using some kinda compression would be nice. The output should be ASCII safe,
and use z85 encoding (this is great because it avoids characters like B<">,
B<'> etc which makes it (relatively) easy to include in JSON without having to
escape stuff).

The Debian package B<coreutils> comes with B<basenc> which can be used for z85
encoding. (Encode with C<basenc --z85>, decode with C<basenc --z85 -d>.)

=over 12

=item Compress:

C<< | xz -c | basenc  --z85 >>


=item Decompress:

C<< | basenc --z85 -d | xz -d >>

=back

The file should be provided with a magic number which specifies both the,
compression, encoding (and possible encryption) as well as the fact that it is
a B<zbd> file. Ideally this should be in the form of a shebang line (so that
the file becomes directly 'executable' by B<zdb>). Maybe implement an option
input/output filtering different stages, maybe something like
B<--format=ed25519:xz:z85> or B<--encoding=ed25519,xz,z85> (the order would
automatically reverse on (the order would automatically reverse on
read/decode).

=head2 Encryption

(Pipe input/output through external secure tool) (also, how make THESE diffs
secure -- encrypted archive of some kind?).

The command line tool B<age> (in Debian package of same name) should be useful
here. The following commands allow input on standard input, and output on
standard output making them ideal to feed a database through them.

=over 9

=item Encrypt:

C<< age --armor --recipients-file=SSH_PUBKEY >>

=item Decrypt:

C<< age --decrypt --identity=SSH_KEYFILE >>

=back

However, B<age> does not support B<ssh-agent>, which would be very cool to use
for password caching, and it would be very cool to use this so that the
password doesn't have to be typed over and over again for every invocation of
B<zdb>.

Also, the B<age> ASCII armored format does not allow for leading and trailing
extra data, so a shebang line would have to be inserted/filtered out by B<zdb>
itself (which also makes the file less usable/recoverable for use outside with
other tools than B<zdb>).

Additionally, it'd be kinda nice to compress the datastream before encrypting
it. The compression schema should be specifiable when writing the file, chosen
automatically on reading (and rewriting, unless overridden by option).

=head2 Add date fields

Date fields should allow for the kind of date available in B<recutils>, but
also allow for simple YYYY only, or YYYY-MM etc. (Like 'date --iso=...' but
also for 'month' and 'year', and also the ones supported by date: 'date',
'hour', 'minute', 'second', 'ns')

=head2 Deleting records & fields

Add option for deleting records/fields. Maybe use option name B<-D>/B<--delete>
to delete records, and B<--delete>[B<=>I<FIELD>[B<,>I<FIELD>]...] for deleting
individual fields. (B<iptables>, B<rsync> and B<git branch> all use
B<--delete>, and with B<iptables> and B<git branch> using shortopt B<-D>.)

Deleting specific fields (when there are multiple of the same name), should use
some kind of numbering. Maybe something like C<B<author[2]>> or C<B<author.2>>
to delete the second 'author' field?

Or maybe use some other scheme? (Like using I<FIELD>B<=>I<VALUE> pairs with
empty value to remove a field---though that might be better reserved for
creating a field, without giving it a value.)


=head2 Hierarchical fields

Each record would be what YAML calls a 'document' (separated by C<---> on a
line of its own). This also requires support for more complicated data
structures (necessitating hierarchical field names). YAML also have alias
support, and a string like C<false> will, if unquoted, be interpreted
differently depending on schema. So schemas need to be in place for this to be
implementable (see https://spacelift.io/blog/yaml).

NO. YAML isn't very nice because of its complicated string escaping syntax, and
also because it doesn't allow for repeated fields.---BUUT a structure that
allows for fields within fields would be very nice. For example, one could
imaging having a musical album database, which could then either have an
'artist' field for the entire album, or (in the instances where this is
relevant) for each song. Also, there should then be a way to define that I want
to search 'song' and 'artist' fields, but only when they apply to the same song
(using the album's 'artist', if the song does not have an artist field of its
own).

=head2 Boolean operator aliases

For maximum sloppiness, maybe implement all of the most common ways of writing
the Boolean operators? This would be a full table:

    ┌─────────────────────────────────┐
    │   Boolean operators             │  From the most tightly binding, to the
    ├────────┬─────┬──────────────────┤  least binding.
    │ NOT    │  !  │  -  (minus)      │
    ├────────┼─────┼──────────────────┤
    │ AND    │  &  │  ␣  (space)      │
    ├────────┼─────┼──────────────────┤
    │ OR     │  |  │  ,  (comma)      │
    ├────────┼─────┼──────────────────┤
    │ XOR    │  ^  │  ;  (semicolon?) │<-- Priority? (Also, maybe use '/'?)
    ├────────┼─────┴──────────────────┤
    │ GROUP¹ │ (…) (parens)           │ ¹ Missing parentheses are automatically
    └────────┴────────────────────────┘   added at the start or end of a query.

Currently only minus, space, comma and parentheses are implemented. The
additional version would just be for convenience for people who are used to
some other name for the operator. For the spelled out versions of the operators
capital letters are required (lower case should always match the words
literally), and (of course) it'll only work when they're unquoted.

Also the more C-like versions C<< && >> and C<< || >> will have exactly same
effect as their non-doubled counterparts---the parser simply sees an empty
search expression between them (which counts as nothing) and the result is the
same as the non-doubled version.

For C<< ! >>, however, this is not true, and doubling that negates the negation.

=cut

#[eof]
