#!/bin/env perl

# https://perl.com/pub/2012/04/perlunicook-standard-preamble.html
use utf8;      # so literals and identifiers can be in UTF-8
use v5.12;     # or later to get "unicode_strings" feature
use strict;    # quote strings, declare variables
use warnings;  # on by default
use warnings  qw(FATAL utf8);    # fatalize encoding glitches
use open      qw(:std :utf8);    # undeclared streams in UTF-8
use charnames qw(:full :short);  # unneeded in v5.16

use Data::Dumper;

my $pager_pid;
END {
    if ($? > 0) {
        kill('TERM', $pager_pid) if $pager_pid;
    } else {
        close STDOUT or die "Can't close standard output: $!\n";
    }
    wait();                                    # wait for pager to exit
}

our $AUTHOR='zrajm <zrajm@zrajm.org>';
our $VERSION='0.3.3';                          # https://semver.org/
our $VERSION_DATE='18 November 2025';
our $CREATED_DATE='11 November 2025'; # never change this!
our $PROGRAM = (split '/', decode(__FILE__))[-1];
our $USAGE = <<"USAGE_END";
Usage: $PROGRAM [OPTION]... [--] [[%TYPE] [QUERY]... [FIELD=VALUE]...]...
Manipulate ZDB database.

      --color[=WHEN]      When to highlight matches (default: 'auto')
                          WHEN: 'auto', 'always' or 'never'
  -c                      Always highlight matches (--color=always)
  -C                      Never highlight matches (--color=never)
  -f, --file=FILE         Specify ZDB input file
  -h, --help              Show this help and exit
      --help-query        Show QUERY syntax (it's very googlish)
  -i, --ignore-case       Ignore case when searching (default)
  -I, --no-ignore-case    Don't ignore case when searching
      --manpage           Show zdb manpage
      --pager=CMD         Use CMD as pager (default: 'pager')
      --paging[=WHEN]     When to use pager (default: 'auto')
  -p                      Always use pager (--paging=always)
  -P                      Never use pager (--paging=never)
      --test              Run built-in unit tests
      --version           Show version and exit

QUERY arguments are joined (with space) before being parsed. If FIELD=VALUE
pairs are given (with no QUERY), create new record containing those fields; if
QUERY is given, add the fields to the first matching record.

ZDB always make minimal changes to files. Comments and whitespace are
preserved, and resorting is only done on request.

NOTE: QUERY cannot start with '-', unless preceded by '--' option. Putting a
space (or comma) at the beginning of the QUERY argument also works.
USAGE_END
our $QUERY = <<"QUERY_END";
NOTE: QUERY cannot start with '-', unless preceded by '--' option. Prefixing
query with space (or comma) also works.

Special characters (in order of precedence)
-------------------------------------
  \e[1m[...]\e[m      Field index
  \e[1m:\e[m (colon)  Field name delimiter
  \e[1m-\e[m (minus)  NOT
  \e[1m␣\e[m (space)  AND
  \e[1m,\e[m (comma)  OR
  \e[1m(...)\e[m      Grouping

* \e[1mname:\e[m = Find records with field called 'name'.
* \e[1m-name:\e[m = \e[1m-(name:)\e[m = Find records without field 'name'.
* \e[1mname:emma\e[m = \e[1m(name: && name:emma)\e[m = Find records where field 'name' exists
  and contains 'emma'.
* \e[1m-name:emma\e[m = \e[1m-(name: || name:emma)\e[m = Find records without field 'name', and
  records where it exists, but does not contain 'emma'.
* \e[1mname:-emma\e[m = \e[1m(name: && -name:emma)\e[m = Find records where field 'name' exists,
  but does not contain 'emma'.

* \e[1m(-name):emma\e[m = \e[1m(-name: && name:emma)\e[m = NONSENSE. Find records without field
  'name', but where field name contains 'emma'.

QUERY_END
our $QUERY2 = <<"QUERY_END";

* \e[1mname:emma\e[m = match records which have field called 'name',
  containing word 'emma'.

\e[1m-name:emma\e[m = \e[1m-(name:emma)\e[m = match records where
\e[1m-name:emma\e[m = \e[1m-(name:emma)\e[m = match records where

FIELD,FIELD2:VALUE1 VALUE2

FIELD[INDEX]:       --- FIELD must exist
FIELD[INDEX]:EXPR   --- must match EXPR
EXPR                --- EXPR must match some field

'name,alias:lars emma' = name,((alias:lars) emma)
  * find records containing either word 'name'
  * OR records containing an 'alias' field with the word 'lars', and any
    field with the word 'emma'

'name,alias:lars emma' = ((name,alias):(lars emma))

'name,alias:lars' 'emma' = ((name,alias):lars) emma

'name,alias:lars,emma' = ((name,alias):(lars,emma))

'name,alias:lars' , 'emma' = ((name,alias):lars),emma <-- REALLY?

or
   and  and and
             or  or
[  [],  [], [[], []]]

#['or', QUERY...]
#['and', QUERY...]
['not', QUERY...]

[qr//, qr//]   # matcher

-(field:thingy)

field:(-thingy, other)

Boolean precedence:


Meaning that: NOT -> AND -> OR (`a, -b c` = `a, (-b c)`).

tlh:(tlha tlhup)

(en sv):(bok,book)

(en sv):(bok,tlh:book)

# Option to enable/disable diacritics (without 'a' would match 'ä')
QUERY_END

# Recutils:
# https://www.gnu.org/software/recutils/manual/recutils.html
#  * field name: '[a-zA-Z%][a-zA-Z0-9_]*'
#  * type name:  '[a-zA-Z][a-zA-Z0-9_]*'

###############################################################################
# Functions
{
    use Encode ();
    state sub OPT() { Encode::FB_CROAK | Encode::LEAVE_SRC }
    sub encode { eval { Encode::encode('UTF-8', shift // $_, OPT) } }
    sub decode { eval { Encode::decode('UTF-8', shift // $_, OPT) } }
}

sub version {
    my ($years)    = $CREATED_DATE =~ m#(\d{4})#;
    my ($end_year) = $VERSION_DATE =~ m#(\d{4})#;
    $years .= "-$end_year" unless $years eq $end_year;
    return <<~"VERSION_END";
    $PROGRAM $VERSION ($VERSION_DATE)
    Copyright (C) $years $AUTHOR
    License GPLv2: GNU GPL version 2 <https://gnu.org/licenses/gpl-2.0.html>.
    This is free software: you are free to change and redistribute it.
    VERSION_END
}

sub manpage {
    # Run 'pod2man'.
    open my $fh, '-|', qw/pod2man --utf8 --errors=die/,
        "--release=$PROGRAM $VERSION", __FILE__
        or die "Can't exec 'pod2man': $!\n";
    my @manpage = <$fh>;
    close($fh) or die (
        "Command 'pod2man' failed: " .
        ($! || "Exit status " . ($? >> 8)) . "\n");

    # Output result to 'man'.
    my $pid = open(STDOUT, '|-', qw/man -l -/)
        or die "Can't exec 'man': $!\n";
    print @manpage;
    exit 0;
}

# FIXME: Test some actual queries
#        my $record = record(<<~"END_RECORD");
#            country	Greenland
#            name	Anders Grönroot
#            END_RECORD
sub test {
    sub x { my ($x) = @_; return $x }
    # OR mode (default).
    !Query::any(\&x, [])           or die "Query::any => []";
     Query::any(\&x, [1])          or die "Query::any => [1]";
    !Query::any(\&x, [0, 0])       or die "Query::any => [0, 0]";
     Query::any(\&x, [0, 1])       or die "Query::any => [0, 1]";
     Query::any(\&x, [1, 0])       or die "Query::any => [1, 0]";
     Query::any(\&x, [1, 1])       or die "Query::any => [1, 1]";
    !Query::any(\&x, [0, 0, 0])    or die "Query::any => [0, 0, 0]";
     Query::any(\&x, [0, 0, 1])    or die "Query::any => [0, 0, 1]";
     Query::any(\&x, [0, 1, 0])    or die "Query::any => [0, 1, 0]";
     Query::any(\&x, [0, 1, 1])    or die "Query::any => [0, 1, 1]";
     Query::any(\&x, [1, 0, 0])    or die "Query::any => [1, 0, 0]";
     Query::any(\&x, [1, 0, 1])    or die "Query::any => [1, 0, 1]";
     Query::any(\&x, [1, 1, 0])    or die "Query::any => [1, 1, 0]";
     Query::any(\&x, [1, 1, 1])    or die "Query::any => [1, 1, 1]";
    # AND mode.
     Query::all(\&x, [])           or die "Query::all => []";
     Query::all(\&x, [1])          or die "Query::all => [1]";
    !Query::all(\&x, [0, 0])       or die "Query::all => [0, 0]";
    !Query::all(\&x, [0, 1])       or die "Query::all => [0, 1]";
    !Query::all(\&x, [1, 0])       or die "Query::all => [1, 0]";
     Query::all(\&x, [1, 1])       or die "Query::all => [1, 1]";
    !Query::all(\&x, [0, 0, 0])    or die "Query::all => [0, 0, 0]";
    !Query::all(\&x, [0, 0, 1])    or die "Query::all => [0, 0, 1]";
    !Query::all(\&x, [0, 1, 0])    or die "Query::all => [0, 1, 0]";
    !Query::all(\&x, [0, 1, 1])    or die "Query::all => [0, 1, 1]";
    !Query::all(\&x, [1, 0, 0])    or die "Query::all => [1, 0, 0]";
    !Query::all(\&x, [1, 0, 1])    or die "Query::all => [1, 0, 1]";
    !Query::all(\&x, [1, 1, 0])    or die "Query::all => [1, 1, 0]";
     Query::all(\&x, [1, 1, 1])    or die "Query::all => [1, 1, 1]";
    # OR mode (default).
    !Query::recurse(\&x, [])           or die "Query::recurse => []";
     Query::recurse(\&x, [1])          or die "Query::recurse => [1]";
    !Query::recurse(\&x, [0, 0])       or die "Query::recurse => [0, 0]";
     Query::recurse(\&x, [0, 1])       or die "Query::recurse => [0, 1]";
     Query::recurse(\&x, [1, 0])       or die "Query::recurse => [1, 0]";
     Query::recurse(\&x, [1, 1])       or die "Query::recurse => [1, 1]";
    !Query::recurse(\&x, [0, 0, 0])    or die "Query::recurse => [0, 0, 0]";
     Query::recurse(\&x, [0, 0, 1])    or die "Query::recurse => [0, 0, 1]";
     Query::recurse(\&x, [0, 1, 0])    or die "Query::recurse => [0, 1, 0]";
     Query::recurse(\&x, [0, 1, 1])    or die "Query::recurse => [0, 1, 1]";
     Query::recurse(\&x, [1, 0, 0])    or die "Query::recurse => [1, 0, 0]";
     Query::recurse(\&x, [1, 0, 1])    or die "Query::recurse => [1, 0, 1]";
     Query::recurse(\&x, [1, 1, 0])    or die "Query::recurse => [1, 1, 0]";
     Query::recurse(\&x, [1, 1, 1])    or die "Query::recurse => [1, 1, 1]";
    # AND mode.
     Query::recurse(\&x, [], 1)        or die "Query::recurse => []";
     Query::recurse(\&x, [1], 1)       or die "Query::recurse => [1]";
    !Query::recurse(\&x, [0, 0], 1)    or die "Query::recurse => [0, 0]";
    !Query::recurse(\&x, [0, 1], 1)    or die "Query::recurse => [0, 1]";
    !Query::recurse(\&x, [1, 0], 1)    or die "Query::recurse => [1, 0]";
     Query::recurse(\&x, [1, 1], 1)    or die "Query::recurse => [1, 1]";
    !Query::recurse(\&x, [0, 0, 0], 1) or die "Query::recurse => [0, 0, 0]";
    !Query::recurse(\&x, [0, 0, 1], 1) or die "Query::recurse => [0, 0, 1]";
    !Query::recurse(\&x, [0, 1, 0], 1) or die "Query::recurse => [0, 1, 0]";
    !Query::recurse(\&x, [0, 1, 1], 1) or die "Query::recurse => [0, 1, 1]";
    !Query::recurse(\&x, [1, 0, 0], 1) or die "Query::recurse => [1, 0, 0]";
    !Query::recurse(\&x, [1, 0, 1], 1) or die "Query::recurse => [1, 0, 1]";
    !Query::recurse(\&x, [1, 1, 0], 1) or die "Query::recurse => [1, 1, 0]";
     Query::recurse(\&x, [1, 1, 1], 1) or die "Query::recurse => [1, 1, 1]";
}

###############################################################################

sub uniq {
    my %seen;
    return grep { !$seen{$_}++ } @_;
}

# FIXME: Should replace all control chars with equivalent '\x' code.
sub quotefunny {
    local ($_) = @_;
    local $" = '';
    my %t = ("\0" => '\0', "\a" => '\a', "\b" => '\b', "\e" => '\e',
             "\f" => '\f', "\n" => '\n', "\r" => '\r', "\t" => '\t');
    s#[@{[ keys(%t) ]}]#$t{$&}#g;
    return $_;
}

sub stringify_hashref {
    my ($x) = @_;
    my $txt = join('', map { "$_: $x->{$_}\n" } keys %$x);
    $txt =~ s#^#  #mg;
    return "{\n$txt}\n";
}

sub stringify_query {
    my ($query) = @_;
    return stringify_hashref($query->()) if ref($query) eq 'CODE';
    if (ref($query) eq 'ARRAY') {
        my $txt = join('', map { stringify_query($_) } @$query);
        $txt =~ s#^# · #mg;
        return "[\n$txt]\n";
    }
    die "Error in query " . ref($query);
}

# FIXME: remove & instead use loaded ZDB file
# my $record = record(<<~"END_RECORD");
#     country	Greenland
#     name	Anders Grönroot
#     END_RECORD
sub record {
    my ($str) = @_;
    my @record;
    while ($str =~ m#\G(\n*)(\w+)(\h+)(.*)(\n)#gc) {
        push(@record, { field => $2, value => $4, space => [$1, $3, $5] });
    }
    return \@record;
}

###############################################################################

# FIXME: Be smarter. Don't load entire file into memory in constructor.
# Also, maybe don't hardcode record and field separators?
#
# NOTE: Final record contain only whitespace (no data).
{
    package ZDB;

    #my $ENTRY_SEPARATOR = qr/((?:\n|\A)\n+)(?!\h)/;
    my $FIELD_SEPARATOR = qr/(?<=\n(?!\s))/;
    my $ENTRY_REGEX = qr/((?:.+\R(?:\R+\h)?)+)/;
    sub new {
        my ($class, $file) = @_;
        my $fh = open_file($file);
        my $self = {
            file => $file,
            fh   => $fh,
            rec  => [split($ENTRY_REGEX, do { local $/; <$fh> })],
            num  => 0,
        };
        return bless($self, $class);
    }

    sub open_file {
        my ($file) = @_;
        if (defined $file) {
            open(my $fh, '<', $file)
                or die "Can't open file '$file' for reading: $!\n";
            return $fh;
        }
        die "Can't read standard input from terminal\n" if -t STDIN;
        return *STDIN;
    }

    # Final record will have only space, no data.
    use Data::Dumper;
    sub read_record {
        my ($self) = @_;
        my ($spc, $txt) = splice(@{$self->{rec}}, 0, 2);
        return ()     if not defined($spc);
        return ($spc) if not defined($txt);

        my $FIELD_END = qr/(\n)(?!\s)/;
        my $FIELD_SEP = qr/\h+/;

        # FIXME: Handling of comments?
        my @record; #      1    2       [3]         [4]    5
        while ($txt =~ m/\G(\n*)(.*?)(?:($FIELD_SEP)(.*?))?($FIELD_END)/gcs) {
            push(@record, {
                field => $2,
                value => $4 // '',
                space => [$1, $3 // '', $5],
            });
        }
        return ($spc, @record);
    }

    sub DESTROY {
        my ($self) = @_;
        close($self->{fh}) or die defined($self->{file})
            ? "Can't close file '$self->{file}': $!\n"
            : "Can't close standard input: $!\n"
            if $self->{fh};
    }
}

###############################################################################

{
    package Query;
    #            or
    #            |and and
    #            ||   |
    #my $query = [[], []];
    sub new {
        my ($class, $query_str) = @_;

        # FIXME: actually parse query
        my $query = [[
            map { match_value_regex(qr/\b$_\b/i) } split(/\s+/, $query_str)
        ]];
        my $self = { query => $query };
        return bless($self, $class);
    }

    # Returns a matcher function. Matcher function takes two args ($field name &
    # $value) and returns true/false. If called without args it returns a structure
    # to describe itself.
    sub match_value_regex {
        my ($regex) = @_;
        my ($INVERT, $UNINVERT) = ("\e[7m", "\e[27m");
        return sub {
            my ($field, $value) = @_ or return {
                # structure describing ourself
                type  => 'regex',
                match => 'value',
                regex => $regex,
            };
            #return $value =~ $regex;  # simple true/false
            return $value =~ s#$regex#$INVERT$&$UNINVERT#g
                ? ($field, $value) : ();
        };
    }

    # Test all elements in $array by invoking callback (passing the element as
    # arg). If third argument is provided and is truthy, it'll operate in AND
    # (or all) mode, without it OR (or any) mode is used
    my $VERBOSE_RECURSE = 0;
    sub recurse {                       # $and: true = AND/all / false = OR/any
        my ($func, $array, $and) = @_;
        say('  ' . ($and ? 'AND' : 'OR')) if $VERBOSE_RECURSE;
        my $match = $and;
        for (@$array) {
            $match = !$and if $func->($_) xor $and;
        }
        return $match;
    }
    sub any {
        my ($func, $list) = @_;
        for (@$list) { return 1 if $func->($_) }
        return ();
    }
    sub all {
        my ($func, $list) = @_;
        for (@$list) { return () unless $func->($_) }
        return 1;
    }

    # FIXME: Be smarter about short-circuiting (it can be done when no
    # highlight is needed, e.g. on a negative match, or when highlight is off).
    #
    # SHORTCUTTING: version (will only highlight first match).
    # sub recurse { # $and: true = AND/all / false = OR/any
    #     my ($func, $array, $and) = @_;
    #     say('  ' . ($and ? 'AND' : 'OR')) if $VERBOSE_RECURSE;
    #     for (@$array) {
    #         return !$and if $func->($_) xor $and;
    #     }
    #     return $and;
    # }

    sub match {
        my ($self, $record, $lvl) = @_;
        return _match($self->{query}, $record);
    }

    sub _match {
        my ($query, $record, $lvl) = @_;
        $lvl //= 0;                            # even = AND, odd = OR

        # Subquery.
        if (ref($query) eq 'ARRAY') {
            my $match = recurse(
                sub {
                    my ($subquery) = @_;
                    return _match($subquery, $record, !$lvl);
                },
                $query,
                $lvl % 2,
            );
            return $match ? $record : '';
        }

        die "Error in query" unless ref($query) eq 'CODE';

        my $match = 0;
        for my $field (@$record) {
            my ($name, $value) = ($field->{field}, $field->{value});

            #say "----------------------------------------";
            my ($pre, $sep, $post) = @{ $field->{space} };
            # say "READ: << '" . quotefunny("$pre$name$sep$value$post") . "'";
            # print "PROC: ", stringify_hashref($query->());

            my @hilited = $query->($name, $value);
            if (@hilited) {
                # Insert hilited values into record.
                my ($name2, $value2) = @hilited;
                push(@{$field->{field_hilite}}, $name2)  if $name2  ne $name;
                push(@{$field->{value_hilite}}, $value2) if $value2 ne $value;

                #($name, $value) = @hilited;
                #print "('$name', '$value') matches " . Dumper($query->());
                $match = 1;
            }
        }
        return $match ? $record : '';
    }
}

# Merges strings with ANSI background highlight. All strings must be identical
# except for their ANSI markup. Background color, bold, dim & bold/dim reset,
# invert & invert reset are stripped and background highlight (or invert) is
# replaced. Any overlapping highlights will have a bright background + bold text
# (regardless of the number of overlapping highlights). BUG: This function will
# naïvely destroy any ANSI codes with semicolon-separated arguments (e.g.
# `\e[58;5;<n>m`), if any of the arguments looks a code that should be
# processed. To avoid this, only feed this function text with ANSI codes w/o
# arguments, or codes with colon-separated arguments.
sub merge_ansi {
    my @str = @_ or die "Need at least one string";

    # Strip ANSI from all strings. Remember position & string.
    my $ESC = qr/\e\[([0-9;:]*)m/;
    my %ansi;
    for (@str) {
        my $i = 0;                             # count removed chars
        s{$ESC}{                               # remove & add to %ansi
            push @{$ansi{ pos() - $i }}, split(';', $1);
            $i += length($&);
            '';
        }ge;
    }
    # Check that strings are identical after ANSI stripping.
    if ((@str = uniq(@str)) > 1) {
        die("Strings must not differ after stripping ANSI codes:\n",
            map { "  '$_'\n" } @str);
    }
    #                          STYLE   FOREGR.  BACKGR.
    my $NORMAL = '22;39;49'; # unbold; normal;  normal
    my $HILITE = '22;30;46'; # unbold; black;   teal
    my $EXTRA  = '1;30;106'; # bold;   black;   bright teal

    # Go through removed strings, in order.
    my ($out, $col, $prev_col, $prev_pos) = ('', 0, 0, 0);
    for my $pos (sort { $a <=> $b } keys %ansi) {

        # Strip bold, dim, bold/dim reset, normal & bright background.
        my @ansi = grep {
            $col += 1 if /^(7|(4|10)[0-8])$/;  # background color
            $col -= 1 if /^(27|49|109)$/;      # background reset
            !/^(1|2|7|22|27|4\d|10\d)$/;
        } @{$ansi{$pos}};

        # Set ANSI hilite (for $col > 2 just use $EXTRA).
        if ($col > $prev_col) {            # intensity went up
            push(@ansi, $HILITE) if $col == 1;
            push(@ansi, $EXTRA)  if $col >= 2;
        } elsif ($col < $prev_col) {       # intensity went down
            push(@ansi, $HILITE) if $col == 1;
            push(@ansi, $NORMAL) if $col == 0;
        }

        # Insert substring & ANSI code.
        $out .= substr($str[0], $prev_pos, $pos - $prev_pos)
            . (@ansi ? "\e[" . join(';', @ansi) . "m" : '');
        ($prev_pos, $prev_col) = ($pos, $col);
    }
    return $out . substr($str[0], $prev_pos) . ($col > 0 ? $NORMAL : '');
}

###############################################################################

sub whenarg {
    my ($arg) = @_;
    my $opt = do {
        local $_ = $arg // $ARGV[0] // '';
        /^(auto  |if-tty|tty)$/x ? -t STDOUT :
        /^(always|force |yes)$/x ?         1 :
        /^(never |none  |no )$/x ?        '' : undef;
    };
    if (defined $opt) {                        # option found
        shift @ARGV if not defined($arg);      # '--color WHEN' (w/o equals)
        return $opt;
    }
    # Option value not found.
    die "Unknown argument '$arg' for '--color'\n",
        "Valid arguments are:\n",
        "  - 'always', 'yes', 'force'\n",
        "  - 'never', 'no', 'none'\n",
        "  - 'auto', 'tty', 'if-tty'.\n"
        if defined($arg);                      # '--color=WHEN' (w/ equals)
    return 1;
}

###############################################################################
# Main

local %SIG = (
    __WARN__ => sub { warn("$PROGRAM: @_") },
    __DIE__  => sub {
        die @_ if $^S;                         # abort if called inside eval
        my $tip = (my $msg = "@_") =~ s/\.$//; # ending in '.' = extra help
        die("$PROGRAM: $msg",
            $tip ? "Try '$PROGRAM --help' for more information.\n" : ());
    });

my $out;
my @query = ();
my %opt = (
    color  => -t STDOUT,
    file   => undef,
    man    => '',
    nocase => 1,
    pager  => $ENV{PAGER} // 'pager',
    paging => -t STDOUT,
    test   => 0,
);
@ARGV = map { decode } @ARGV;
while (@ARGV) {
    local $_ = shift;
    /^-/ or do { push(@query, $_); next };  # non-option = QUERY
    # NOTE! Shortopts w/o args in here!
    s/(?<=^-[^-f]).+//x            and unshift(@ARGV, "-$&"); # bundled opts
    /^        --               $/x and do { push(@query, @ARGV);        last };
    /^ -c                      $/x and do { $opt{color} = 1;            next };
    /^ -C                      $/x and do { $opt{color} = 0;            next };
    /^        --colou?r(=(.*))?$/x and do { $opt{color} = whenarg($2);  next };
    /^(-f(.*)|--file  (=(.*))?)$/x and do { $opt{file} = $2||$4//shift; next };
    /^(-h    |--help          )$/x and do { $out = $USAGE;              next };
    /^(       --help-query    )$/x and do { $out = $QUERY;              next };
    /^(-i    |--ignore-case   )$/x and do { $opt{nocase} = 1;           next };
    /^(-I    |--no-ignore-case)$/x and do { $opt{nocase} = 0;           next };
    /^(       --manpage       )$/x and do { $opt{man} = 1;              next };
    /^        --pager  (=(.*))?$/x and do { $opt{pager} = $2//shift;    next };
    /^        --paging (=(.*))?$/x and do { $opt{paging} = whenarg($2); next };
    /^ -p                      $/x and do { $opt{paging} = 1;           next };
    /^ -P                      $/x and do { $opt{paging} = 0;           next };
    /^(       --test          )$/x and do { $opt{test} = 1;             next };
    /^(       --version       )$/x and do { $out = version();           next };
    die "Unknown option '$_'.\n";
}

$opt{man}  and manpage();
$opt{test} and do { say test() ? 'ALL TESTS OK' : 'TESTS FAILED'; exit };
$out       and do { print $out; exit };

# FIXME: split $opt{pager} (?)
$pager_pid = open(STDOUT, '|-', $opt{pager})   # send all STDOUT through pager
    or die "Can't exec '$opt{pager}': $!\n"    #   (if enabled)
    if $opt{paging};

my $query = new Query("@query");
my $zdb = new ZDB($opt{file});
while (my ($prespace, @field) = $zdb->read_record()) {

    $query->match(\@field) or next;

    # FIXME: Don't waste time generating hilite if --color=never.
    print $prespace;
    for my $field (@field) {
        my $name  = ($opt{color} ? $field->{field_hilite} : ()) || [$field->{field}];
        my $value = ($opt{color} ? $field->{value_hilite} : ()) || [$field->{value}];
        my ($pre, $sep, $post) = @{ $field->{space} };

        print $pre . merge_ansi(@$name) . $sep . merge_ansi(@$value) . $post;
    }
}

__END__

FIXME: See 'man pod2man' & 'man perlpodstyle' for a list of all sections that
should be included in a man page.

=encoding utf8

=head1 NAME

zdb - Manipulate ZDB database


=head1 SYNOPSIS

B<zdb> [I<OPTION>]... [B<-->] [[I<QUERY>]... [I<FIELD>B<=>I<VALUE>]...]...


=head1 DESCRIPTION

B<zdb> is a utility for searching and manipulating human-readable text-based
database files in the ZDB format, it is similar to GNU Recutils in intention,
with the difference that it strives to have a more human-readable query
language as well. Queries are thus usually short and simple, yet allow for
complex queries when needed.

B<zdb> operates in four different modes, depending on whether either or both of
I<QUERY> and I<FIELD>B<=>I<VALUE> have been provided.

=over 2

=item * Only I<QUERY>: Find and show matching records.

=item * Only I<FIELD>B<=>I<VALUE>: Insert given fields as a new record.

=item * Both I<QUERY> and I<FIELD>B<=>I<VALUE>: Insert given fields in matching
record.

=item * Neither: Display a database summary.

=back

=head1 OPTIONS

=over 7

=item B<--color>[B<=>I<WHEN>], B<--colour>[B<=>I<WHEN>] (default: B<auto>)

Whether to highlight search matches in the output.

I<WHEN> may be one of the following (B<--paging> works the same):

=over 2

=item * B<always> (alias: B<yes>, B<force>) enables highlighting.

=item * B<never> (alias: B<no>, B<none>) disables highlighting.

=item * B<auto> (alias: B<tty>, B<if-tty>) enables highlighting only when
output is connected to a terminal. -- That is, it will be disabled if user has
piped the output to another command (S<C<| CMD>>) or directed it to a file
(S<C<< > FILE >>>), but otherwise it will be enabled.

=back

Using B<--color> (without I<WHEN>) means B<--color=always>; not using
B<--color> means B<--color=auto>. (See also B<-c> and B<-C>; Option from
B<grep>/B<ls>, but the alias forms of I<WHEN> are only used by B<ls>.)

=item B<-c>

Enable highlighting. Short for B<--color=always>.

=item B<-C>

Disable highlighting. Short for B<--color=never>.

=item B<-f>I<FILE>, B<--file=>I<FILE>

Read input from given I<FILE>, without this option, input is read from standard
input. (TODO: See L</Atomic file updates>; Option from B<grep>.)

=item B<-h>, B<--help>

Output a usage message and exit.

=item B<--help-query>

Display a cheat sheet for the QUERY syntax. (See also L</QUERIES> below).

=item B<-i>, B<--ignore-case> (default)

Ignore case distinctions when searching. (This is the default.) This option is
useful to override any previously given B<--no-ignore-case> on the same command
line. (Option from B<grep>.)

=item B<-I>, B<--no-ignore-case>

Consider case distinctions when searching. By default search is
case-insensitive, use this option to override that. (Option from B<grep>.)

=item B<--manpage>

Display the B<zdb> manpage (as extracted from Perl POD documentation from the
source). The outputted manpage is fed to B<man>. (TODO: See L</Show manpage
using B<$MANPAGER>>.)

=item B<--pager=>I<CMD> (default: B<pager>)

Specify a which command to use as a pager. (A pager is a program like B<more>
or B<less> which allows you to navigate through large output in a more
user-friendly way.) When a pager is used, the output of B<zdb> is piped to the
pager, and the standard output of the pager takes the place of B<zdb>'s
standard output. (Meaning that if a user pipes the output of B<zdb>, that pipe
will also pass through the pager, if it is enabled.)

By default B<pager> (which is often set to B<less> by our Linux distro) is
used. This option overrides any pager specification given in the B<$PAGER>
environment variable. (TODO: See L</Support arguments for pager>; Option from
B<man>/B<bat>/B<delta>.)

=item B<--paging>[B<=>I<WHEN>] (default: B<auto>)

Whether to use a pager for the output.

I<WHEN> may be: B<auto>, B<always> or B<never> (and works the same as for
B<--color>). Using B<--paging> (without I<WHEN>) means B<--paging=always>; not
using B<--paging> means B<--paging=auto>. (See also B<--pager=>I<CMD>, B<-p>
and B<-P>; Option from B<bat>/B<delta>.)

=item B<-p>

Always use pager. (Short for B<--paging=always>.)

=item B<-P>

Never use pager. (Short for B<--paging=never>; Option from B<bat>.)

=item B<--test>

Run built-in unit tests. (TODO: See L</Use framework for unit tests>.)

=item B<--version>

Output version information and exit.

=back


=head1 QUERIES

All the QUERY arguments are joined together before being read by B<zdb>. This
allows simple queries to written without quotes. Queries are case-insensitive
by default (unless overridden with B<--no-ignore-case>).

Missing parentheses are automatically added at the start/end of the query.
Query words only match whole words in the data, to match a partial word use
C<*>. For example, use C<x*> to match words beginning with "x", or C<*x> for to
match words ending in "x".

Boolean operators are also supported:

    ┌──────────────────────┐
    │   Boolean operators  │   From the most tightly binding, to the
    ├────────┬─────────────┤   least binding.
    │ NOT    │  -  (minus) │
    ├────────┼─────────────┤
    │ AND    │  ␣  (space) │
    ├────────┼─────────────┤
    │ OR     │  ,  (comma) │
    ├────────┼─────────────┤   ¹ Missing parentheses are automatically
    │ GROUP¹ │ (…) (parens)│     added at the start or end of a query.
    └────────┴─────────────┘


=head2 Field Prefixes

To search only a specific field, use 'I<prefix>B<:>I<value>' (that is,
B<name:anderson> will search for 'anderson' all 'name' fields). No prefix is
the same as 'B<*:>'. The prefix syntax actually the same as the value part, so
stuff like B<(name,alias):anderson> (in 'name' or 'alias' fields, search for
'anderson') also works! You can also chain the prefixes B<name:magnus:anderson>
will match entries that that have a 'name' field that contains both 'magnus'
and 'anderson' (in any order). Just 'name:' (without value) matches entries
that has a field by that name (ignoring any field value).

Searching is supposed to be simple, and queries fast and easy to write. Enter
Sloppy Query, the *very forgiving* query language. Did you not balance your
parentheses? Never mind,

The query language is called 'sloppy query', it is inspired by web search
engines, and focused on expressing a lot with a little. (ZDB is to a large
extent inspired by GNU Recutils, but one of the things I didn't like with
Recutils was its pretty verbose query language.)


=head2 Quoting

To search for a literal occurrence of a character mentioned above, put
character in question in double quotes ('x*' searches for words starting with
'x', while '"x*"'>

Special characters may be put in double quotes to perform a literal search for
them. However, quoting in the shell is a little bit tricky, since the shell
strips quotes. This means that for a quote to be visible to B<zdb> it must be
quoted twice. The following will find the phrase 'great britain' in any country
field:

    zdb 'country:"great britain"' <FILE

This next command will instead find all records with a 'country' field
containing 'great', and any field containing 'britain' (probably B<not> what
you intended).

    zdb 'country:great britain' <FILE

A third option is using the B<:> operator multiple times. The following command
will match all 'country' fields that contain both the words 'great' and
'britain' (in the same field, but regardless of which order the words come in).

    zdb 'country:great:britain' <FILE

Single quotes do not have a special meaning in a QUERY. The following will
match 'name' fields containing "d'armond":

    zdb "name:d'armond" <FILE


=head1 ENVIRONMENT

=over 7

=item B<$PAGER>

If B<$PAGER> is set its value is used as the name of the program used to
display the manual page. By default, B<pager> is used, falling back to B<cat>
if B<pager> is not found or is not executable.

The value may be a simple command name or a command with arguments, and may use
shell quoting (backslashes, single quotes, or double quotes). It may not use
pipes to connect multiple commands; if you need that, use a wrapper script,
which may take the file to display either as an argument or on standard input.

=back


=head1 AUTHOR

Copyright (C) 1998-2025 zrajm <zrajm@klingonska.org>.


=head1 HISTORY

[2025-11-11 00:51-06:50] & [2025-11-11 15:26-21:32, 00:04-02:20] v0.0.1 -
Primitive initial functionality. Output a ZDB file (given a ZDB file on
standard input), and split the file into records internally while preserving
whitespace between records (and at the beginning & ending of file).

[2025-11-11 15:26-16:11, 19:45-21:31] & [2025-11-12 00:04-03:28, 05:02-07:12]
[2025-11-14 01:03-06:30, 18:10-11:42] v0.1.0 - Defined internal query format,
and internal data format. File now loads into the new format loading.
Implemented search (using a simple hardcoded query). Added hiliting of search
result (including overlapping matches).

[2025-11-14 11:42-12:22] v0.1.1 - Documented internals somewhat.

[2025-11-15 15:33-17:06] v0.2.0 - Added B<--pager> and B<--manpage> options.
Pager defaults to whatever is specified in the $PAGER environment variable
(defaulting to B<less>). B<--manpage> option shows simple documentation (not
yet manpage formatted, but its *something*). Also removed the command line
options B<--help-internals> and B<--todo> as this info is now part of the
manpage instead.

[2025-11-16 00:06-04:39], [2025-11-16 23:18-02:27], [2025-11-17 04:29-08:10] &
[2025-11-17 14:13-17:07] v0.3.0 - Pager now defaults to B<pager> (instead of
B<less>). Better suppression of pager (or, in the case of B<--manpage>,
manpager) when there are errors. Extensive rewrite of docs.

[2025-11-17, 18:53-19:23] v0.3.1 - Moved query parsing and matching into Query
module.

[2025-11-18 19:26-19:39] v0.3.2 - Now gets QUERY from command line arguments.
Very basic, all arguments a simply AND:ed, and each pattern is expected to
match a whole word (with no wildcards or anything).

[2025-11-18 19:39-21:21] v0.3.3 - Added B<--paging> option.


=head1 COPYRIGHT AND LICENSE

Copyright 2025, zrajm L<zrajm@klingonska.org>. ZDB file format copyright
1998-2025 by zrajm and Klingonska Akademien in Uppsala, Sweden.
L<https://klingonska.org>.

License GPLv2: GNU General Public License version 2 or later
L<https://gnu.org/licenses/gpl-2.0.html>. This is free software: you are free
to change and redistribute it. There is NO WARRANTY, to the extent permitted by
law. (See also C<zdb --version>.)


=head1 SEE ALSO

B<zdb> is partly inspired by GNU Recutils. -- When I first heard about Recutils
I was delighted to find that its file format it strikingly similar to the
plain-text 'database' format I've used for my Klingon dictionary since the very
end of the last century (see L<https://klingonska.org/dict/dict.zdb>). I was to
a large degree inspired by the shortcomings of Recutils -- it's query language
is verbose and pretty inflexible (I felt I could do better!), and Recutils does
not highlight matches.

Hence, this little project! :)


=head1 INTERNALS

=head2 Internal Query Format

Internally query tree structure, consisting is a nested lists, where the leaves
are functions. These matcher functions are called for each field/value pair,
and aggregated. When not matching they should return the empty list, and when
matching they return the field and value pair again, with possible highlights
(achieved using ANSI escape code for inverting '\e7m...\e[27m'). When a matcher
function is called without arguments, it should return data about itself (exact
format to be decided) -- this is to allow for creating a cleaned-up version of
the original query by traversing the tree.

The root node of the tree is always OR:ed, and nodes inside that are AND:ed,
and those inside those are OR:ed etc.

    or
    |and       and
    ||or  or   |
    |||   |    |
    [[[], []], []]

When creating the query a function that returns a function is used. A query may
thus be constructed along the lines of:

                or
                |and
                ||
    my $query = [[value_regex(qr/name/i), value_regex(qr/McGuffin/i)]]

This would result in a query that'll find all records which have a field
'name', and a value containing 'McGuffin' (case-insensitively). More complex
functions could of course be constructed, maybe something like?

    regex({ name => qr/name/i, value => qr/McGuffin/i })


=head2 Internal Database Representation

In the main loop `read_record()` is called over and over until the entire file
has been read. (And the query is used in turn for each record to determine
whether or not to output it.) `read_record()` returns two values, first is a
string containing the leading whitespace (i.e. the whitespace occurring between
this record and the previous one), second is an array containing one hashref
for each field in the record. The hashref has the following format:

    { field => ..., value => ..., space => [..., ..., ...] }

Where `field` & `value` are the name & value of the field (these are passed to
the matcher functions when performing a query), and `space` contains the
whitespace coming before the field, between name and value and after the field.
In the ZDB format the first value is always an empty string, and the last
always a newline. (These are mostly for future proofing, and having the option
of supporting other data formats in the future.) Middle value may vary
depending on the amount of whitespace used between the field name and value.


=head1 FUTURE

Below are some planned future features.

=head2 Read QUERY arguments

=head2 Search in comments

Option to enable/disable searching comment. By default comments should not be
searched.

=head2 Automatic linebreaking

There should maybe be an option to produce automatic linebreaks in fields? How
about fields containing explicit newlines? (Like an address, or poetry?)

=head2 Verify manpage contents

Should verify that all manadotry parts of a manpage are included. (See C<man
perlpodstyle>.)

=head2 Atomic file updates

Currently data is always output to standard output, regardless of whether it
was read from standard input, or from file specified with the B<--file=>I<FILE>
option. In the future, input on stdin should result in output to stdout, but
using B<--file=>I<FILE> should result in the ZDB being atomically updated. A
tempfile is written (next to the input file, e.g. with the name
'B<.>I<FILE>B<.tmp>'). Upon successful outputting of this file, is renamed
to replace the old file.

=head2 Inserting new records

When I<FIELD>B<=>I<VALUE> pairs arguments are given, but no I<QUERY> is present
on the command line, the data should be inserted as a new record in the
database.

=head2 Inserting fields into existing records

When I<FIELD>B<=>I<VALUE> pairs arguments are given, and a I<QUERY> is present
on the command line, the data should be inserted into the first(?) matching as
record.

=head2 Record and field sorting

Sorting, being a slow operation, should never be performed on the whole
dictionary unless explicitly requested. (Using a B<--sort> option, perhaps?)
However, when inserting records or fields, the sort order should be respected,
and the new record/field should be inserted late as possible in the record set
or record.

B<Record sort:> In B<recutils> the B<%sort> option is used to define how
records are sorted relative to each other in a record set. For example,
B<recutils> uses B<S<%sort: author year>> to specify should be sorted primarily
by the content of the B<author> field, and secondarily by B<year>.

B<Field sort:> B<recutils> has no way of sorting fields within a record. So
will have to be invented here. Sorting should be stable, so that if there are
interleaved fields of different names, the internal order between fields of the
same name should be retained (but the different field names should no longer be
interleaved) after sorting.

=head2 Field types and field verification

B<recutils> uses B<%type> and B<%typedef> for this purpose. Also the fields
B<%mandatory>, B<%allowed>, B<%prohibit>, B<%unique> and B<%constraint>. In
normal operation B<zdb> should give an error if user tries to add (or remove)
records or fields that break what's allowed. A B<--force> option should allow
one to make breaking changes. But verification of whole database might be too
slow to perform for each modification. (Maybe add B<--verify> option or
similar for checking the whole database?)

=head2 Support arguments for pager

The B<--pager=>I<CMD> option and B<$PAGER> environment variable should both
allow for arguments being used. (The B<bat --help> gives an example B<--pager>
use as '--pager "less -RF"'.) Currently using a space in either B<$PAGER> or
B<--pager=>I<CMD> will most likely cause an error. (See B<--pager> in man(1),
and B<bat --help>.)

=head2 Suppression of length output

It would be convenient to be able to suppress lengthy output and/or disable
pager for short output (shorter than a screenful?).

=head2 Show manpage using B<$MANPAGER>

The B<--manpage> option should use the B<$MANPAGER> environment variable to
determine how do display its manpage.

=head2 Use framework for unit tests

The unit tests run with B<--test> option are pretty primitive. They should be
rewritten to run using some standard Perl test framework (like C<Test::Simple>,
C<Test::More>). Maybe also the Perl Modulino pattern as well? B<NOTE:> Any
testing framework modules should B<only> be loaded when running tests, never
during normal execution.

=head2 Add record sets B<%rec> (and B<%doc>)

Implement B<recutils> 'record set' field B<%rec>. Record set name should
probably use the same limitations (and recommendations) as B<recutils> do (see
'Naming Record Types' in the B<recutils> manual).

=head2 Status command

Giving an input file, but no I<QUERY> or I<FIELD>B<=>I<VALUE> pairs should give
a summary of the input file. Summary should include B<%rec> and B<%doc> fields
for each record set, and there should also be a summary of the fields usage
used for each set. For example we could see something like the following to
indicate that the field 'tlh' occurs once in 3033 records, while the field
'cite' occurs zero times in 2627 records, once in 320 records etc.

    %rec	words
    %doc	Klingonska Akademien's Klingon Dictionary
    tlh		1 -- 1:3033
    ...
    cite	0..5,7 -- 0:2627 1:320 2:58 3:18 4:4 5:4 7:3
    ...

Should also have a look at what the B<recinf> command outputs for additional
inspiration.

=head2 File locking

There should be some protection to avoid having multiple instances of B<zdb>
trying to modify the same file at the same time.

=head2 Highlight color config

User should be able to choose highlight color.

=head2 Undo

As a database is updated, patches should be generated and saved into a
directory next to the database. (Similar to how tempfiles are stored.) So,
maybe create a directory 'B<.>I<FILE>B<.undo>' (or 'B<.>I<FILE>B<.diff>') and
then, inside that directory create patches called
I<YYYYMMDDB<_>HHMMSS>B<.diff>. This way, any of the patches can be reapplied to
undo that change.---Or, possibly, diffs could instead be added to a B<.zip>
file (or other archive).

=head2 Encryption

(Pipe input/output through external secure tool) (also, how make THESE diffs
secure -- encrypted archive of some kind?).

=head2 Add date fields

Date fields should allow for the kind of date available in B<recutils>, but
also allow for simple YYYY only, or YYYY-MM etc. (Like 'date --iso=...' but
also for 'month' and 'year', and also the ones supported by date: 'date',
'hour', 'minute', 'second', 'ns')

=head2 Deleting records & fields

Add options for deleting records and fields. For example, add a
B<--delete-record> option which deletes all records matched by QUERY, and a
B<--delete-field> which deletes all fields matched by query (though the option
names should probably be shorter). Or maybe use some other scheme? (Like using
I<FIELD>B<=>I<VALUE> pairs with empty value to remove a field---though that
might be better reserved for setting a field, but leaving it empty.)

=cut

#[eof]
