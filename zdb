#!/bin/env perl

# https://perl.com/pub/2012/04/perlunicook-standard-preamble.html
use utf8;      # so literals and identifiers can be in UTF-8
use v5.12;     # or later to get "unicode_strings" feature
use strict;    # quote strings, declare variables
use warnings;  # on by default
use warnings  qw(FATAL utf8);    # fatalize encoding glitches
use open      qw(:std :utf8);    # undeclared streams in UTF-8
use charnames qw(:full :short);  # unneeded in v5.16

our $AUTHOR='zrajm <zrajm@zrajm.org>';
our $VERSION='0.6.2';                          # https://semver.org/
our $VERSION_DATE='26 November 2025';
our $CREATED_DATE='11 November 2025'; # never change this!
our $PROGRAM = (split '/', decode(__FILE__))[-1];
our $USAGE = <<"USAGE_END";
Usage: $PROGRAM [OPTION]... [--] QUERY [FIELD=VALUE]... [FILE]
       $PROGRAM [OPTION]... -eQUERY... [--] [FIELD=VALUE]... [FILE]
Manipulate ZDB database.

      --color[=WHEN]      When to highlight matches (default: 'auto')
                          WHEN: 'auto', 'always' or 'never'
  -c                      Always highlight matches (--color=always)
  -C                      Never highlight matches (--color=never)
  -e, --match=QUERY       Specify QUERY explicitly (usually omitted)
  -h, --help              Show this help and exit
      --help-query        Show QUERY syntax (it's very googlish)
  -i, --ignore-case       Ignore case when searching (default)
  -I, --no-ignore-case    Don't ignore case when searching
  -M, --manual            Show zdb manual page (with 'man')
      --pager=CMD         Use CMD as pager (default: 'pager')
      --paging[=WHEN]     When to use pager (default: 'auto')
  -p                      Always use pager (--paging=always)
  -P                      Never use pager (--paging=never)
      --test              Run built-in unit tests
      --version           Show version and exit

QUERY arguments are joined (with space) before being parsed. If FIELD=VALUE
pairs are given (with no QUERY), create new record containing those fields; if
QUERY is given, add the fields to the first matching record.

ZDB always make minimal changes to files. Comments and whitespace are
preserved, and resorting is only done on request.

NOTE: QUERY cannot start with '-', unless preceded by '--' option. Putting a
space (or comma) at the beginning of the QUERY argument also works.
USAGE_END
our $QUERY = <<"QUERY_END";
NOTE: QUERY cannot start with '-', unless preceded by '--' option. Prefixing
query with space (or comma) also works.

Special characters (in order of precedence)
-------------------------------------
  \e[1m[...]\e[m      Field index
  \e[1m:\e[m (colon)  Field name delimiter
  \e[1m-\e[m (minus)  NOT
  \e[1m␣\e[m (space)  AND
  \e[1m,\e[m (comma)  OR
  \e[1m(...)\e[m      Grouping

* \e[1mname:\e[m = Find records with field called 'name'.
* \e[1m-name:\e[m = \e[1m-(name:)\e[m = Find records without field 'name'.
* \e[1mname:emma\e[m = \e[1m(name: && name:emma)\e[m = Find records where field 'name' exists
  and contains 'emma'.
* \e[1m-name:emma\e[m = \e[1m-(name: || name:emma)\e[m = Find records without field 'name', and
  records where it exists, but does not contain 'emma'.
* \e[1mname:-emma\e[m = \e[1m(name: && -name:emma)\e[m = Find records where field 'name' exists,
  but does not contain 'emma'.

* \e[1m(-name):emma\e[m = \e[1m(-name: && name:emma)\e[m = NONSENSE. Find records without field
  'name', but where field name contains 'emma'.

QUERY_END
our $QUERY2 = <<"QUERY_END";

* \e[1mname:emma\e[m = match records which have field called 'name',
  containing word 'emma'.

\e[1m-name:emma\e[m = \e[1m-(name:emma)\e[m = match records where
\e[1m-name:emma\e[m = \e[1m-(name:emma)\e[m = match records where

FIELD,FIELD2:VALUE1 VALUE2

FIELD[INDEX]:       --- FIELD must exist
FIELD[INDEX]:EXPR   --- must match EXPR
EXPR                --- EXPR must match some field

'name,alias:lars emma' = name,((alias:lars) emma)
  * find records containing either word 'name'
  * OR records containing an 'alias' field with the word 'lars', and any
    field with the word 'emma'

'name,alias:lars emma' = ((name,alias):(lars emma))

'name,alias:lars' 'emma' = ((name,alias):lars) emma

'name,alias:lars,emma' = ((name,alias):(lars,emma))

'name,alias:lars' , 'emma' = ((name,alias):lars),emma <-- REALLY?

or
   and  and and
             or  or
[  [],  [], [[], []]]

#['or', QUERY...]
#['and', QUERY...]
['not', QUERY...]

[qr//, qr//]   # matcher

-(field:thingy)

field:(-thingy, other)

Boolean precedence:


Meaning that: NOT -> AND -> OR (`a, -b c` = `a, (-b c)`).

tlh:(tlha tlhup)

(en sv):(bok,book)

(en sv):(bok,tlh:book)

# Option to enable/disable diacritics (without 'a' would match 'ä')
QUERY_END

my $pager_pid;
END {
    if ($? > 0) {
        kill('TERM', $pager_pid) if $pager_pid;
    } else {
        close STDOUT or die "Can't close standard output: $!\n";
    }
    wait();                                    # wait for pager to exit
}

# Recutils:
# https://www.gnu.org/software/recutils/manual/recutils.html
#  * field name: '[a-zA-Z%][a-zA-Z0-9_]*'
#  * type name:  '[a-zA-Z][a-zA-Z0-9_]*'

###############################################################################
# Functions
{
    use Encode ();
    state sub OPT() { Encode::FB_CROAK | Encode::LEAVE_SRC }
    sub encode { eval { Encode::encode('UTF-8', shift // $_, OPT) } }
    sub decode { eval { Encode::decode('UTF-8', shift // $_, OPT) } }
}

sub version {
    my ($years)    = $CREATED_DATE =~ m#(\d{4})#;
    my ($end_year) = $VERSION_DATE =~ m#(\d{4})#;
    $years .= "-$end_year" unless $years eq $end_year;
    return <<~"VERSION_END";
    $PROGRAM $VERSION ($VERSION_DATE)
    Copyright (C) $years $AUTHOR
    License GPLv2: GNU GPL version 2 <https://gnu.org/licenses/gpl-2.0.html>.
    This is free software: you are free to change and redistribute it.
    VERSION_END
}

sub manpage {
    # Run 'pod2man'.
    open(my $fh, '-|', qw/pod2man --utf8 --errors=die/,
        "--release=$PROGRAM $VERSION", __FILE__)
        or die "Can't exec 'pod2man': $!\n";
    my @manpage = <$fh>;
    close($fh) or die (
        "Command 'pod2man' failed: " .
        ($! || "Exit status " . ($? >> 8)) . "\n");

    # Output result to 'man'.
    my $pid = open(STDOUT, '|-', qw/man -l -/)
        or die "Can't exec 'man': $!\n";
    print @manpage;
    exit 0;
}

###############################################################################

sub uniq {
    my %seen;
    return grep { !$seen{$_}++ } @_;
}

# FIXME: Should replace all control chars with equivalent '\x' code.
sub quotefunny {
    local ($_) = @_;
    local $" = '';
    my %t = ("\0" => '\0', "\a" => '\a', "\b" => '\b', "\e" => '\e',
             "\f" => '\f', "\n" => '\n', "\r" => '\r', "\t" => '\t');
    s#[@{[ keys(%t) ]}]#$t{$&}#g;
    return $_;
}

sub stringify_hashref {
    my ($x) = @_;
    my $txt = join('', map { "$_: $x->{$_}\n" } keys %$x);
    $txt =~ s#^#  #mg;
    return "{\n$txt}\n";
}

sub stringify_query {
    my ($query) = @_;
    return stringify_hashref($query->()) if ref($query) eq 'CODE';
    if (ref($query) eq 'ARRAY') {
        my $txt = join('', map { stringify_query($_) } @$query);
        $txt =~ s#^# · #mg;
        return "[\n$txt]\n";
    }
    die "Error in query " . ref($query);
}

# my $record = record(<<~"END_RECORD");
#     country	Greenland
#     name	Anders Grönroot
#     END_RECORD
sub record {
    my ($str) = @_;
    my @record;
    while ($str =~ m#\G(\n*)(\w+)(\h+)(.*)(\n)#gc) {
        push(@record, { field => $2, value => $4, space => [$1, $3, $5] });
    }
    return \@record;
}

###############################################################################

# FIXME: Be smarter. Don't load entire file into memory in constructor.
# Also, maybe don't hardcode record and field separators?
#
# NOTE: Final record contain only whitespace (no data).
{
    package ZDB;

    #my $ENTRY_SEPARATOR = qr/((?:\n|\A)\n+)(?!\h)/;
    my $FIELD_SEPARATOR = qr/(?<=\n(?!\s))/;
    my $ENTRY_REGEX = qr/((?:.+\R(?:\R+\h)?)+)/;
    sub new {
        my ($class, $file) = @_;
        my $fh = open_file($file);
        my $self = {
            file => $file,
            fh   => $fh,
            rec  => [split($ENTRY_REGEX, do { local $/; <$fh> })],
            num  => 0,
        };
        return bless($self, $class);
    }

    sub open_file {
        my ($file) = @_;
        if (defined $file) {
            open(my $fh, '<', $file)
                or die "Can't open file '$file' for reading: $!\n";
            return $fh;
        }
        die "Can't read standard input from terminal\n" if -t STDIN;
        return *STDIN;
    }

    # Final record will have only space, no data.
    use Data::Dumper;
    sub read_record {
        my ($self) = @_;
        my ($spc, $txt) = splice(@{$self->{rec}}, 0, 2);
        return ()     if not defined($spc);
        return ($spc) if not defined($txt);

        my $FIELD_END = qr/(\n)(?!\s)/;
        my $FIELD_SEP = qr/\h+/;

        # FIXME: Handling of comments?
        my @record; #      1    2       [3]         [4]    5
        while ($txt =~ m/\G(\n*)(.*?)(?:($FIELD_SEP)(.*?))?($FIELD_END)/gcs) {
            push(@record, {
                field => $2,
                value => $4 // '',
                space => [$1, $3 // '', $5],
            });
        }
        return ($spc, @record);
    }

    sub DESTROY {
        my ($self) = @_;
        close($self->{fh}) or die defined($self->{file})
            ? "Can't close file '$self->{file}': $!\n"
            : "Can't close standard input: $!\n"
            if $self->{fh};
    }
}

###############################################################################

{
    package Query;
    #            or
    #            |and and
    #            ||   |
    #my $query = [[], []];
    sub new {
        my ($class, $query_str) = @_;

        # FIXME: actually parse query
        my $query = [[
            map { match_value_regex(qr/\b$_\b/i) } split(/\s+/, $query_str)
        ]];
        my $self = { query => $query };
        return bless($self, $class);
    }

    # Returns a matcher function. Matcher function takes two args ($field name &
    # $value) and returns true/false. If called without args it returns a structure
    # to describe itself.
    sub match_value_regex {
        my ($regex) = @_;
        my ($INVERT, $UNINVERT) = ("\e[7m", "\e[27m");
        return sub {
            my ($field, $value) = @_ or return {
                # structure describing ourself
                type  => 'regex',
                match => 'value',
                regex => $regex,
            };
            #return $value =~ $regex;  # simple true/false
            return $value =~ s#$regex#$INVERT$&$UNINVERT#g
                ? ($field, $value) : ();
        };
    }

    # Test all elements in $array by invoking callback (passing the element as
    # arg). If third argument is provided and is truthy, it'll operate in AND
    # (or all) mode, without it OR (or any) mode is used
    my $VERBOSE_RECURSE = 0;
    sub recurse {                       # $and: true = AND/all / false = OR/any
        my ($func, $array, $and) = @_;
        say('  ' . ($and ? 'AND' : 'OR')) if $VERBOSE_RECURSE;
        my $match = $and;
        for (@$array) {
            $match = !$and if $func->($_) xor $and;
        }
        return $match;
    }
    sub any {
        my ($func, $list) = @_;
        for (@$list) { return 1 if $func->($_) }
        return ();
    }
    sub all {
        my ($func, $list) = @_;
        for (@$list) { return () unless $func->($_) }
        return 1;
    }

    # FIXME: Be smarter about short-circuiting (it can be done when no
    # highlight is needed, e.g. on a negative match, or when highlight is off).
    #
    # SHORTCUTTING: version (will only highlight first match).
    # sub recurse { # $and: true = AND/all / false = OR/any
    #     my ($func, $array, $and) = @_;
    #     say('  ' . ($and ? 'AND' : 'OR')) if $VERBOSE_RECURSE;
    #     for (@$array) {
    #         return !$and if $func->($_) xor $and;
    #     }
    #     return $and;
    # }

    sub match {
        my ($self, $record, $lvl) = @_;
        return _match($self->{query}, $record);
    }

    sub _match {
        my ($query, $record, $lvl) = @_;
        $lvl //= 0;                            # even = AND, odd = OR

        # Subquery.
        if (ref($query) eq 'ARRAY') {
            my $match = recurse(
                sub {
                    my ($subquery) = @_;
                    return _match($subquery, $record, !$lvl);
                },
                $query,
                $lvl % 2,
            );
            return $match ? $record : '';
        }

        die "Error in query" unless ref($query) eq 'CODE';

        my $match = 0;
        for my $field (@$record) {
            my ($name, $value) = ($field->{field}, $field->{value});

            #say "----------------------------------------";
            my ($pre, $sep, $post) = @{ $field->{space} };
            # say "READ: << '" . quotefunny("$pre$name$sep$value$post") . "'";
            # print "PROC: ", stringify_hashref($query->());

            my @hilited = $query->($name, $value);
            if (@hilited) {
                # Insert hilited values into record.
                my ($name2, $value2) = @hilited;
                push(@{$field->{field_hilite}}, $name2)  if $name2  ne $name;
                push(@{$field->{value_hilite}}, $value2) if $value2 ne $value;

                #($name, $value) = @hilited;
                #print "('$name', '$value') matches " . Dumper($query->());
                $match = 1;
            }
        }
        return $match ? $record : '';
    }

    # FIXME: Test some actual queries
    #        my $record = record(<<~"END_RECORD");
    #            country	Greenland
    #            name	Anders Grönroot
    #            END_RECORD
    sub test {
        require Test::More;                    # load at runtime
        import Test::More;                     #   (not compile time)
        my $f = sub { shift() };               # return 1st arg as-is
        # OR mode (default).
        ok(!any($f, []),            "any => []");
        ok( any($f, [1]),           "any => [1]");
        ok(!any($f, [0, 0]),        "any => [0, 0]");
        ok( any($f, [0, 1]),        "any => [0, 1]");
        ok( any($f, [1, 0]),        "any => [1, 0]");
        ok( any($f, [1, 1]),        "any => [1, 1]");
        ok(!any($f, [0, 0, 0]),     "any => [0, 0, 0]");
        ok( any($f, [0, 0, 1]),     "any => [0, 0, 1]");
        ok( any($f, [0, 1, 0]),     "any => [0, 1, 0]");
        ok( any($f, [0, 1, 1]),     "any => [0, 1, 1]");
        ok( any($f, [1, 0, 0]),     "any => [1, 0, 0]");
        ok( any($f, [1, 0, 1]),     "any => [1, 0, 1]");
        ok( any($f, [1, 1, 0]),     "any => [1, 1, 0]");
        ok( any($f, [1, 1, 1]),     "any => [1, 1, 1]");
        # AND mode.
        ok( all($f, []),            "all => []");
        ok( all($f, [1]),           "all => [1]");
        ok(!all($f, [0, 0]),        "all => [0, 0]");
        ok(!all($f, [0, 1]),        "all => [0, 1]");
        ok(!all($f, [1, 0]),        "all => [1, 0]");
        ok( all($f, [1, 1]),        "all => [1, 1]");
        ok(!all($f, [0, 0, 0]),     "all => [0, 0, 0]");
        ok(!all($f, [0, 0, 1]),     "all => [0, 0, 1]");
        ok(!all($f, [0, 1, 0]),     "all => [0, 1, 0]");
        ok(!all($f, [0, 1, 1]),     "all => [0, 1, 1]");
        ok(!all($f, [1, 0, 0]),     "all => [1, 0, 0]");
        ok(!all($f, [1, 0, 1]),     "all => [1, 0, 1]");
        ok(!all($f, [1, 1, 0]),     "all => [1, 1, 0]");
        ok( all($f, [1, 1, 1]),     "all => [1, 1, 1]");
        # OR mode (default).
        ok(!recurse($f, []),           "recurse => []");
        ok( recurse($f, [1]),          "recurse => [1]");
        ok(!recurse($f, [0, 0]),       "recurse => [0, 0]");
        ok( recurse($f, [0, 1]),       "recurse => [0, 1]");
        ok( recurse($f, [1, 0]),       "recurse => [1, 0]");
        ok( recurse($f, [1, 1]),       "recurse => [1, 1]");
        ok(!recurse($f, [0, 0, 0]),    "recurse => [0, 0, 0]");
        ok( recurse($f, [0, 0, 1]),    "recurse => [0, 0, 1]");
        ok( recurse($f, [0, 1, 0]),    "recurse => [0, 1, 0]");
        ok( recurse($f, [0, 1, 1]),    "recurse => [0, 1, 1]");
        ok( recurse($f, [1, 0, 0]),    "recurse => [1, 0, 0]");
        ok( recurse($f, [1, 0, 1]),    "recurse => [1, 0, 1]");
        ok( recurse($f, [1, 1, 0]),    "recurse => [1, 1, 0]");
        ok( recurse($f, [1, 1, 1]),    "recurse => [1, 1, 1]");
        # AND mode.
        ok( recurse($f, [], 1),        "recurse => []");
        ok( recurse($f, [1], 1),       "recurse => [1]");
        ok(!recurse($f, [0, 0], 1),    "recurse => [0, 0]");
        ok(!recurse($f, [0, 1], 1),    "recurse => [0, 1]");
        ok(!recurse($f, [1, 0], 1),    "recurse => [1, 0]");
        ok( recurse($f, [1, 1], 1),    "recurse => [1, 1]");
        ok(!recurse($f, [0, 0, 0], 1), "recurse => [0, 0, 0]");
        ok(!recurse($f, [0, 0, 1], 1), "recurse => [0, 0, 1]");
        ok(!recurse($f, [0, 1, 0], 1), "recurse => [0, 1, 0]");
        ok(!recurse($f, [0, 1, 1], 1), "recurse => [0, 1, 1]");
        ok(!recurse($f, [1, 0, 0], 1), "recurse => [1, 0, 0]");
        ok(!recurse($f, [1, 0, 1], 1), "recurse => [1, 0, 1]");
        ok(!recurse($f, [1, 1, 0], 1), "recurse => [1, 1, 0]");
        ok( recurse($f, [1, 1, 1], 1), "recurse => [1, 1, 1]");
        done_testing();
    }
}

# Merges strings with ANSI background highlight. All strings must be identical
# except for their ANSI markup. Background color, bold, dim & bold/dim reset,
# invert & invert reset are stripped and background highlight (or invert) is
# replaced. Any overlapping highlights will have a bright background + bold text
# (regardless of the number of overlapping highlights). BUG: This function will
# naïvely destroy any ANSI codes with semicolon-separated arguments (e.g.
# `\e[58;5;<n>m`), if any of the arguments looks a code that should be
# processed. To avoid this, only feed this function text with ANSI codes w/o
# arguments, or codes with colon-separated arguments.
sub merge_ansi {
    my @str = @_ or die "Need at least one string";

    # Strip ANSI from all strings. Remember position & string.
    my $ESC = qr/\e\[([0-9;:]*)m/;
    my %ansi;
    for (@str) {
        my $i = 0;                             # count removed chars
        s{$ESC}{                               # remove & add to %ansi
            push @{$ansi{ pos() - $i }}, split(';', $1);
            $i += length($&);
            '';
        }ge;
    }
    # Check that strings are identical after ANSI stripping.
    if ((@str = uniq(@str)) > 1) {
        die("Strings must not differ after stripping ANSI codes:\n",
            map { "  '$_'\n" } @str);
    }
    #                          STYLE   FOREGR.  BACKGR.
    my $NORMAL = '22;39;49'; # unbold; normal;  normal
    my $HILITE = '22;30;46'; # unbold; black;   teal
    my $EXTRA  = '1;30;106'; # bold;   black;   bright teal

    # Go through removed strings, in order.
    my ($out, $col, $prev_col, $prev_pos) = ('', 0, 0, 0);
    for my $pos (sort { $a <=> $b } keys %ansi) {

        # Strip bold, dim, bold/dim reset, normal & bright background.
        my @ansi = grep {
            $col += 1 if /^(7|(4|10)[0-8])$/;  # background color
            $col -= 1 if /^(27|49|109)$/;      # background reset
            !/^(1|2|7|22|27|4\d|10\d)$/;
        } @{$ansi{$pos}};

        # Set ANSI hilite (for $col > 2 just use $EXTRA).
        if ($col > $prev_col) {            # intensity went up
            push(@ansi, $HILITE) if $col == 1;
            push(@ansi, $EXTRA)  if $col >= 2;
        } elsif ($col < $prev_col) {       # intensity went down
            push(@ansi, $HILITE) if $col == 1;
            push(@ansi, $NORMAL) if $col == 0;
        }

        # Insert substring & ANSI code.
        $out .= substr($str[0], $prev_pos, $pos - $prev_pos)
            . (@ansi ? "\e[" . join(';', @ansi) . "m" : '');
        ($prev_pos, $prev_col) = ($pos, $col);
    }
    return $out . substr($str[0], $prev_pos) . ($col > 0 ? $NORMAL : '');
}

###############################################################################

sub whenarg {
    my ($arg) = @_;
    my $opt = do {
        local $_ = $arg // $ARGV[0] // '';
        /^(auto  |if-tty|tty)$/x ? -t STDOUT :
        /^(always|force |yes)$/x ?         1 :
        /^(never |none  |no )$/x ?        '' : undef;
    };
    if (defined $opt) {                        # option found
        shift @ARGV if not defined($arg);      # '--color WHEN' (w/o equals)
        return $opt;
    }
    # Option value not found.
    die "Unknown argument '$arg' for '--color'\n",
        "Valid arguments are:\n",
        "  - 'always', 'yes', 'force'\n",
        "  - 'never', 'no', 'none'\n",
        "  - 'auto', 'tty', 'if-tty'.\n"
        if defined($arg);                      # '--color=WHEN' (w/ equals)
    return 1;
}

###############################################################################
# Main

local %SIG = (
    __WARN__ => sub { warn("$PROGRAM: @_") },
    __DIE__  => sub {
        die @_ if $^S;                         # abort if called inside eval
        my $tip = (my $msg = "@_") =~ s/\.$//; # ending in '.' = extra help
        die("$PROGRAM: $msg",
            $tip ? "Try '$PROGRAM --help' for more information.\n" : ());
    });

my $out;
my (@arg, @query);
my %opt = (
    color  => -t STDOUT,
    file   => undef,
    man    => '',
    nocase => 1,
    pager  => $ENV{PAGER} // $ENV{ZDBPAGER} // 'pager',
    paging => -t STDOUT,
    test   => 0,
);
@ARGV = map { decode } @ARGV;
while (@ARGV) {
    local $_ = shift;
    /^ -.                       /x or  do { push(@arg, $_); next }; # non-opt
    # NOTE! Shortopts with args must be in (negated) character class below!
    s/(?<=^-[^-e]).+//x            and unshift(@ARGV, "-$&"); # bundled opts
    /^        --               $/x and do { push(@arg, @ARGV);          last };
    /^ -c                      $/x and do { $opt{color} = 1;            next };
    /^ -C                      $/x and do { $opt{color} = 0;            next };
    /^        --colou?r(=(.*))?$/x and do { $opt{color} = whenarg($2);  next };
    /^(-e(.*)|--match (=(.*))?)$/x and do { push @query, $2||$4//shift; next };
    /^(-h    |--help          )$/x and do { $out = $USAGE;              next };
    /^(       --help-query    )$/x and do { $out = $QUERY;              next };
    /^(-i    |--ignore-case   )$/x and do { $opt{nocase} = 1;           next };
    /^(-I    |--no-ignore-case)$/x and do { $opt{nocase} = 0;           next };
    /^(-M    |--manual        )$/x and do { $opt{man} = 1;              next };
    /^        --pager  (=(.*))?$/x and do { $opt{pager} = $2//shift;    next };
    /^        --paging (=(.*))?$/x and do { $opt{paging} = whenarg($2); next };
    /^ -p                      $/x and do { $opt{paging} = 1;           next };
    /^ -P                      $/x and do { $opt{paging} = 0;           next };
    /^(       --test          )$/x and do { $opt{test} = 1;             next };
    /^(       --version       )$/x and do { $out = version();           next };
    die "Unknown option '$_'.\n";
}

$opt{man}  and manpage();
$opt{test} and do { Query::test(); exit };
$out       and do { print $out;    exit };
die "Only one FILE may be specified.\n" if @arg > 2;
if (-t STDIN) {                                # get FILE
    die "No FILE specified.\n"                         if @arg == 0;
    die "FILE is '-' but no standard input to read.\n" if $arg[$#arg] eq '-';
    die "FILE '$arg[$#arg]' does not exist.\n"         if not -e $arg[$#arg];
    ($opt{file}) = pop @arg;
} else {                                       # read STDIN
    pop @arg if (@arg && $arg[$#arg] eq '-');
    die "Specify either FILE or standard input, not both.\n" if @arg > 1;
}
if (not @query) {                              # get QUERY (unless got from -e)
    die "No QUERY specified.\n" if @arg == 0;
    @query = shift(@arg);
}

# FIXME: split $opt{pager} (?)
$pager_pid = open(STDOUT, '|-', $opt{pager})   # send all STDOUT through pager
    or die "Can't exec '$opt{pager}': $!\n"    #   (if enabled)
    if $opt{paging};

# If there are multiple queries, the were gotten by -e and should be OR:ed.
# FIXME: Parse each query separately (to resolve unfinished parens etc) then join.
my $query = new Query(join(',', @query));
my $zdb = new ZDB($opt{file});
while (my ($prespace, @field) = $zdb->read_record()) {

    $query->match(\@field) or next;

    # FIXME: Don't waste time generating hilite if --color=never.
    print $prespace;
    for my $field (@field) {
        my $name  = ($opt{color} ? $field->{field_hilite} : ()) || [$field->{field}];
        my $value = ($opt{color} ? $field->{value_hilite} : ()) || [$field->{value}];
        my ($pre, $sep, $post) = @{ $field->{space} };

        print $pre . merge_ansi(@$name) . $sep . merge_ansi(@$value) . $post;
    }
}

__END__

FIXME: See 'man pod2man' & 'man perlpodstyle' for a list of all sections that
should be included in a manpage.

=encoding utf8

=head1 NAME

zdb - Manipulate ZDB database


=head1 SYNOPSIS

=over 1

=item B<zdb> [I<OPTION>]... [B<-->] I<QUERY> [I<FIELD>B<=>I<VALUE>]... [I<FILE>]

=item B<zdb> [I<OPTION>]... B<-e>I<QUERY>... [B<-->] [I<FIELD>B<=>I<VALUE>]... [I<FILE>]

=back


=head1 DESCRIPTION

B<zdb> is a utility for searching and manipulating human-readable text-based
database files (in ZDB format).

A I<FILE> of C<-> stands for standard input. When receiving input on standard
input B<zdb> acts like a text filter (outputting the results to standard
output). When a (non C<->) I<FILE> is specified, that file is updated
(atomically) on success.

The I<QUERY> language is inspired by search engines, and uses (in order of
precedence) C<-> (minus) for NOT, C<␣> (space) for AND, and C<,> for OR, C<(…)>
(parentheses) for grouping, and a prefix notation to specify what fields to
search. (See L</QUERIES> below.)

There are four different modes (based on whether the I<QUERY> and/or
I<FIELD>B<=>I<VALUE> arguments were provided or not):

    ┌───────────────────┬───────────────────────────────┬────────────┐
    │ –                 │ Show database summary         │ read-only  │
    ├───────────────────┼───────────────────────────────┤            │
    │ QUERY             │ Show matching records         │            │
    ├───────────────────┼───────────────────────────────┼────────────┤
    │ QUERY FIELD=VALUE │ Add fields to matching record │ read-write │
    ├───────────────────┼───────────────────────────────┤            │
    │ FIELD=VALUE       │ Insert fields as new record   │            │
    └───────────────────┴───────────────────────────────┴────────────┘


=head1 OPTIONS

=over 7

=item B<--color>[B<=>I<WHEN>], B<--colour>[B<=>I<WHEN>] (default: B<auto>)

Whether to highlight search matches in the output.

I<WHEN> may be one of the following (B<--paging> works the same):

=over 2

=item * B<always> (alias: B<yes>, B<force>) enables highlighting.

=item * B<never> (alias: B<no>, B<none>) disables highlighting.

=item * B<auto> (alias: B<tty>, B<if-tty>) enables highlighting only when
output is connected to a terminal. -- That is, it will be disabled if user has
piped the output to another command (S<C<| CMD>>) or directed it to a file
(S<C<< > FILE >>>), but otherwise it will be enabled.

=back

Using B<--color> (without I<WHEN>) means B<--color=always>; omitting the option
altogether means B<--color=auto>. (See also B<-c> and B<-C>.) (Option inspired
by B<grep>/B<ls> with semantics matching B<ls>, that is, using option without
arg means B<--color=always>, and I<WHEN> values B<yes>/B<force>, B<no>/B<none>
and B<tty>/B<if-tty> are only supported by B<ls>, not B<grep>.)

=item B<-c>

Enable highlighting. Short for B<--color=always>.

=item B<-C>

Disable highlighting. Short for B<--color=never>.

=item B<-e>I<QUERY>, B<--match=>I<QUERY>

Specify I<QUERY> explicitly. Useful when you don't want to put I<QUERY> as the
first argument, or in a situation where I<QUERY> might start with C<-> and be
interpreted as an option. (You can protect your I<QUERY> against this in other
ways too, for example by prefixing it with C<,> or using the B<--> option.)

If this option is repeated, the I<QUERY>(s) are OR:ed together. This means that
a record will be considered matching if one (or more) of the I<QUERY>(s) match.
(Short option inspired by B<grep>, B<sed>, B<awk>; long option by B<ack>.)

=item B<-h>, B<--help>

Output a usage message and exit.

=item B<--help-query>

Display a cheat sheet for the QUERY syntax. (See also L</QUERIES> below).

=item B<-i>, B<--ignore-case> (default)

Ignore case distinctions when searching. (This is the default.) This option is
useful to override any previously given B<--no-ignore-case> on the same command
line. (Option inspired by B<grep>.)

=item B<-I>, B<--no-ignore-case>

Consider case distinctions when searching. By default search is
case-insensitive, use this option to override that. (Option inspired by
B<grep>.)

=item B<-M>, B<--manual>

Display the B<zdb> manual page (with B<man>). The manual page is included in
the 'binary' itself (a Perl program) in the form of Perl-style POD
documentation. (TODO: See L</Show manpage using B<$MANPAGER>>; Option inspired
by B<curl>.)

=item B<--pager=>I<CMD> (default: B<pager>)

Specify a which command to use as a pager. (A pager is a program like B<more>
or B<less> which allows you to navigate through large output in a more
user-friendly way.) When a pager is used, the output of B<zdb> is piped to the
pager, and the standard output of the pager takes the place of B<zdb>'s
standard output. (Meaning that if a user pipes the output of B<zdb>, that pipe
will also pass through the pager, if it is enabled.)

The default command used is B<pager> (which in points to B<less> in many Linux
distros). The B<--pager> option overrides any B<$ZDBPAGER> or B<$PAGER>
environment variable setting. (See also L</ENVIRONMENT>: 'B<$ZDBPAGER>,
B<$PAGER>'; Option inspired by B<man>/B<bat>/B<delta>.)

B<RECOMMENDED:> Add the line C<export ZDBPAGER='less -RFXi'> to your shell's
init file. This will set the B<less> options B<-R> (allow color highlighting),
B<-F> (exit immediately if output fits on screen), B<-X> (disable screen
clearing on exit on some terminals), and B<-i> (turn off case-insensitivity
when searching in B<less>).

=item B<--paging>[B<=>I<WHEN>] (default: B<auto>)

Whether to use a pager for the output.

I<WHEN> may be: B<auto>, B<always> or B<never> (and works the same as for
B<--color>). Using B<--paging> (without I<WHEN>) means B<--paging=always>; not
using B<--paging> means B<--paging=auto>. (See also B<--pager=>I<CMD>, B<-p>
and B<-P>; Option inspired by B<bat>/B<delta>.)

=item B<-p>

Always use pager. (Short for B<--paging=always>.)

=item B<-P>

Never use pager. (Short for B<--paging=never>; Option inspired by B<bat>.)

=item B<--test>

Run built-in unit tests. Tests are run using Perl's standard B<Test::More>
module. However, the module is loaded at runtime, rather than (the way it is
normally done) at compile time---This is to avoid impacting the load time of
normal use of the program (when the the B<--test> option isn't used).

=item B<--version>

Output version information and exit.

=back


=head1 QUERIES

B<zdb> uses a sloppy query language, inspired by web search engines. It strives
to be terse, intuitive, expressive, and forgiving. Unmatched parentheses and
quotes are fine (they will be terminated for you). Text in quotes is
interpreted literally (special characters/operators lose their meaning).

B<NOTE:> QUERY arguments are joined together (with spaces) before being
processed. But remember that the shell processes its quotes before the
arguments are ever seen by B<zdb>. This means that you have to quote your
quotes! It's usually most convenient to put single quotes around your whole
query (which gets eaten by the shell) and then use double quotes inside that if
you need it. For example:

    zdb 'name:("crew member",crewmember)' -fklingon.zdb

Query is matched word-by-word (C<B<cat>> does not match "cats"). An (unquoted)
asterisk (B<*>) may be used to match zero or more letters: C<B<cat*>> matches
both "cat" and "cats" and "catwoman"; C<B<*fix>> matches "fix", "prefix", and
"suffix".

Queries are case-insensitive (unless you use B<--no-ignore-case>).

=head2 Logic Operators

Boolean operators are also supported:

    ┌──────────────┬────────────┐
    │  Character   │  Used For  │  From the most tightly binding, to the
    ├──────────────┼────────────┤  least binding.
    │  :  (colon)  │  prefix    │
    ├──────────────┼────────────┤  Thus: '-a:b, -c d' = '(-(a:b)), (-c d)'.
    │  -  (minus)  │  not       │
    ├──────────────┼────────────┤
    │  ␣  (space)  │  and       │
    ├──────────────┼────────────┤
    │  ,  (comma)  │  or        │
    ├──────────────┼────────────┤  ¹ Any missing parentheses are automatically
    │ (…) (parens) │  grouping¹ │    added at start/end of QUERY.
    └──────────────┴────────────┘


=head2 Field Prefixes

To only search a specific field, a field name prefix (I<FIELD>B<:>I<VALUE>) may
be used. (For example, C<name:anderson> will find all occurrences of 'anderson'
in the 'name' field.) The full syntax is:

[I<FIELD>B<:>]I<VALUE>[B<:>I<VALUE>]...

Where no C<I<FIELD>B<:>> means the same as C<B<*:>…>.

Both I<FIELD> and I<VALUE> may be arbitrarily complex Boolean expressions.
Since B<:> is so tightly binding, however, parentheses are required around each
I<FIELD> and I<VALUE> containing a complex expression.
(C<(name,alias):anderson> will find 'anderson' in either 'name' or 'alias'.)

When multiple I<VALUE>s are chained together (…B<:>I<VALUE>B<:>I<VALUE>),
matching of subsequent I<VALUE> are only attempted in fields that have matched
the previous I<VALUE>(s) in the chain. (Thus, C<name:magnus:anderson> will
match all 'name' fields which contain B<both> 'magnus' and 'anderson', and
C<(name,alias):magnus:anderson> will match 'name' or 'alias' fields that
contain B<both> 'magnus' and 'anderson' B<in the same field>.)

I<FIELD:> (without a value) will match all fields with the specified name
(regardless of value. (C<(name,alias):> will match all records that contain
either a field called 'name' or 'alias'.)


=head2 Quoting

    ┌──────────────────┬───────────────┐
    │  Character       │ Used For      │
    ├──────────────────┼───────────────┤
    │ "…" (quotes)     │ quoting       │
    ├──────────────────┼───────────────┤
    │ ""  (two quotes) │ literal quote │
    ├──────────────────┼───────────────┤
    │  *  (asterisk)   │ word char     │
    └──────────────────┴───────────────┘

Only double quotes (B<">) have a special meaning, single quotes (B<'>) are
taken literally. (C<d'armond> will thus match all occurrences said name.)

All characters inside quotes are taken literally. If you want to search for a
word or phrase that contains special characters (like parentheses, an asterisk,
or spaces) but them inside quotes. (C<phaser pistol> will find records
containing both the words 'phaser' and 'pistol', while C<"phaser pistol"> will
find all occurrences of the phrase "phaser pistol".)

Quotes can begin and end anywhere, and so to search for a phrase where one may
vary use something like B<C<"the "*" of">>. The only exception to this is that
two quotes in a row (regardless of whether it occurs inside or outside of a
quote) will match a literal quote.


=head1 RETURN VALUE

FIXME


=head1 DIAGNOSTICS

FIXME: Add missing error messages

=over 4

=item Can't exec 'man': I<REASON>

This resulted from C<< zdb --manual >> not being able to find or execute the
B<man> viewer needed to show the manpage. On my Linux machine the B<man> tool
is installed by default (and is available in the Debian B<man-db> package). If
worst comes to worst, the documentation is viewable (in the fairly readable
'POD' format) by looking at the program 'binary' as well.

=item Can't exec 'pod2man': I<REASON>

=item Command 'pod2man' failed: I<REASON>

This resulted from C<< zdb --manual >> not being able to find or execute the
Perl tool B<pod2man>, which is used to generate the manpage. This tool comes
with the standard Perl installation, but the documentation can also be found
inside the B<zdb> source code itself (and is fairly readable).

=back


=head1 EXAMPLES

=head2 'Self-searchable' ZDB databases

One may create 'self-searchable' ZDB database, which can be invoked by using
the database file itself as a command. For example, my Klingon dictionary is
called F<klingon.zdb>, and to search for the word 'phaser' I can simply write:

     ./klingon.zdb phaser

To achieve this, a (relatively complicated) shebang (C<#!>) line needs to be
added to the top of the database file. This shebang invokes B<zdb>, and
rearranges the arguments so that name of the database file occurs last in the
command. The following B<shebang> can be used:

    #!/bin/env -S sh -c 'exec zdb "$@" "$0"'

For the above to work B<zdb> needs to be somewhere in your B<$PATH>.

As the shebang command is invoked the first argument (B<$0>) is the name of the
B<zdb> database file (in which the shebang line is found). If we did not invoke
B<sh> to flip the arguments around, B<$0> would have been given as the first
argument (which would've caused B<zdb> to throw an error).

The database file also needs to be executable for this to work.

    chmod +x ZDBFILE

Now, 'executing' the database will pass all arguments given as-is to B<zdb>,
with the name of the database file tucked onto the end of the command line.


=head1 ENVIRONMENT

=over 7

=item B<$ZDBPAGER>,  B<$PAGER> (fallback value: B<pager>)

Defines what command to use as pager for the output. B<$ZDBPAGER> overrides
B<$PAGER>, both of which can be overridden by the B<--pager=>I<CMD> option.

The default command used is B<pager> (which in points to B<less> in many Linux
distros).

B<$ZDBPAGER> may contain any command or command pipeline. But it is inadvisable
to put a command pipeline in B<$PAGER>, as, for example B<man> (which also
reads this variable) does not allow it.

B<RECOMMENDED:> Add the line C<export ZDBPAGER='less -RFXi'> to your shell's
init file. This will set the B<less> options B<-R> (allow color highlighting),
B<-F> (exit immediately if output fits on screen), B<-X> (disable screen
clearing on exit on some terminals), and B<-i> (turn off case-insensitivity
when searching in B<less>).

=back


=head1 FILES

The only file read by B<zdb> is the inputted ZDB database file. Currently all
output is written to standard output, but this B<will change>. In the future a
file specified on the command line will be modified when inserting or deleting
fields/records. Like now, when the ZDB database is given on standard input,
modified content will be written to standard output.


=head1 CAVEATS

FIXME


=head1 RESTRICTIONS

Only two different colors are used when highlighting found matches. This means
that if multiple search terms overlap, the color intensity will only ever
accurately reflect one or two overlapping matches. The color will not increase
beyond that. This is not expected to change in the future. (As overlapping
matches are presumably pretty rare anyways.)


=head1 AUTHOR

Copyright (C) 1998-2025 zrajm <zrajm@klingonska.org>.


=head1 HISTORY

[2025-11-11 00:51-06:50] & [2025-11-11 15:26-21:32, 00:04-02:20] v0.0.1 -
Primitive initial functionality. Output a ZDB file (given a ZDB file on
standard input), and split the file into records internally while preserving
whitespace between records (and at the beginning & ending of file).

[2025-11-11 15:26-16:11, 19:45-21:31] & [2025-11-12 00:04-03:28, 05:02-07:12]
[2025-11-14 01:03-06:30, 18:10-11:42] v0.1.0 - Defined internal query format,
and internal data format. File now loads into the new format loading.
Implemented search (using a simple hardcoded query). Added hiliting of search
result (including overlapping matches).

[2025-11-14 11:42-12:22] v0.1.1 - Documented internals somewhat.

[2025-11-15 15:33-17:06] v0.2.0 - Added B<--pager> and B<--manpage> options.
Pager defaults to whatever is specified in the $PAGER environment variable
(defaulting to B<less>). B<--manpage> option shows simple documentation (not
yet manpage formatted, but its *something*). Also removed the command line
options B<--help-internals> and B<--todo> as this info is now part of the
manpage instead.

[2025-11-16 00:06-04:39], [2025-11-16 23:18-02:27], [2025-11-17 04:29-08:10] &
[2025-11-17 14:13-17:07] v0.3.0 - Pager now defaults to B<pager> (instead of
B<less>). Better suppression of pager (or, in the case of B<--manpage>,
manpager) when there are errors. Extensive rewrite of docs.

[2025-11-17, 18:53-19:23] v0.3.1 - Moved query parsing and matching into Query
module.

[2025-11-18 19:26-19:39] v0.3.2 - Now gets QUERY from command line arguments.
Very basic, all arguments a simply AND:ed, and each pattern is expected to
match a whole word (with no wildcards or anything).

[2025-11-18 19:39-21:21] v0.3.3 - Added B<--paging> option.

[2025-11-18 21:21-21:42] v0.3.4 - Tested/verified and documented the B<$PAGER>
and B<--pager=>I<CMD> capabilities. (Yes, Perl allow more complex commands to
be used.)

[2025-11-19 00:04-01:01] v0.4.0 - Added B<ZDBPAGER> for B<zdb>-specific pager
defaults.

[2025-11-19 02:28-02:41] v0.4.1 - Moved unit tests into Query module.

[2025-11-19 02:41-03:20] v0.4.2 - Now use Test::More for unit tests in Query
module.

[2025-11-20 07:31-09:08] v0.4.3 - Updated manpage. Added description of how to
use B<zdb> as a shebang. Made sure manpage includes all required headlines.
Added notes on L</FILES> and L</RESTRICTIONS>.

[2025-11-23 11:18-13:44] v0.4.4 - Updated manpage with ideas for future.

[2025-11-23 13:44-13:58] v0.5.0 - Renamed B<--manpage> option to B<--manual>
(and added the short option B<-M>). The new option names are the same as those
used by the B<curl> command. Unfortunately, almost no other commands seem to
provide a flag to show their B<man> page, so it isn't very easy to find an
intuitive option name to use. :(

[2025-11-25 08:49-11:29] v0.5.1 - Expanded manpage. Improved chapters
DESCRIPTION, QUERIES (subchapters 'Logic Operators', 'Field Prefixes' and
'Quoting'). Added and clarified a buncha stuff on the 'FUTURE' wishlist.

[2025-11-25 12:31-12:36] v0.5.2 - Moved END {} block to after info variables.

[2025-11-25 02:14-04:57, 11:37-12:56, 17:29-18:01], [2025-11-26 15:08-15:59]
v0.6.0 - Added B<-e>/B<--match> option and removed B<-f>/B<--file> option.
B<--file> was used to specify a database input file (mentioned as being
inspired by B<grep>'s option of the same name) but B<grep> actually uses that
option to specify a file of B<match patterns>, not data! This update brings the
options in line with how B<grep>, B<sed> and B<awk> (actually) works.

[2025-11-26 15:59-17:37] v0.6.1 - Support for '-' argument. QUERY argument now
mandatory (until implementing L</No QUERY = Show database status>). Also
updated usage string to reflect this.

[2025-11-26 18:46-18:59] v0.6.2 - Documentation proofreading & fixes.


=head1 COPYRIGHT AND LICENSE

Copyright 2025, zrajm L<zrajm@klingonska.org>. ZDB file format copyright
1998-2025 by zrajm and Klingonska Akademien in Uppsala, Sweden.
L<https://klingonska.org>.

License GPLv2: GNU General Public License version 2 or later
L<https://gnu.org/licenses/gpl-2.0.html>. This is free software: you are free
to change and redistribute it. There is NO WARRANTY, to the extent permitted by
law. (See also C<zdb --version>.)


=head1 SEE ALSO

B<zdb> is partly inspired by GNU Recutils. -- When I first heard about Recutils
I was delighted to find that its file format it strikingly similar to the
plain-text 'database' format I've used for my Klingon dictionary since the very
end of the last century (see L<https://klingonska.org/dict/dict.zdb>). I was to
a large degree inspired by the shortcomings of Recutils -- it's query language
is verbose and pretty inflexible (I felt I could do better!), and Recutils does
not highlight matches.

Hence, this little project! :)


=head1 INTERNALS

=head2 Internal Query Format

Internally query tree structure, consisting is a nested lists, where the leaves
are functions. These matcher functions are called for each field/value pair,
and aggregated. When not matching they should return the empty list, and when
matching they return the field and value pair again, with possible highlights
(achieved using ANSI escape code for inverting '\e7m...\e[27m'). When a matcher
function is called without arguments, it should return data about itself (exact
format to be decided) -- this is to allow for creating a cleaned-up version of
the original query by traversing the tree.

The root node of the tree is always OR:ed, and nodes inside that are AND:ed,
and those inside those are OR:ed etc.

    or
    |and       and
    ||or  or   |
    |||   |    |
    [[[], []], []]

When creating the query a function that returns a function is used. A query may
thus be constructed along the lines of:

                or
                |and
                ||
    my $query = [[value_regex(qr/name/i), value_regex(qr/McGuffin/i)]]

This would result in a query that'll find all records which have a field
'name', and a value containing 'McGuffin' (case-insensitively). More complex
functions could of course be constructed, maybe something like?

    regex({ name => qr/name/i, value => qr/McGuffin/i })


=head2 Internal Database Representation

In the main loop `read_record()` is called over and over until the entire file
has been read. (And the query is used in turn for each record to determine
whether or not to output it.) `read_record()` returns two values, first is a
string containing the leading whitespace (i.e. the whitespace occurring between
this record and the previous one), second is an array containing one hashref
for each field in the record. The hashref has the following format:

    { field => ..., value => ..., space => [..., ..., ...] }

Where `field` & `value` are the name & value of the field (these are passed to
the matcher functions when performing a query), and `space` contains the
whitespace coming before the field, between name and value and after the field.
In the ZDB format the first value is always an empty string, and the last
always a newline. (These are mostly for future proofing, and having the option
of supporting other data formats in the future.) Middle value may vary
depending on the amount of whitespace used between the field name and value.


=head1 FUTURE

Below are some planned future features. (Some section has separate FIXME
comments that will be fixed in the future as well.)

=head2 Read QUERY arguments

=head2 Search in comments

Option to enable/disable searching comment. By default comments should not be
searched.

=head2 Smart case matching

B<ucg> (UniversalCodeGrep) and B<ag> (The Silver Searcher) both have a
B<--smart-case> option (B<ag> also has shortopt B<-S>, while B<ucg> doesn't
have a shortopt). B<ag> describes it as: "Match case-sensitively if there are
any uppercase letters in PATTERN, case-insensitively otherwise. Enabled by
default." And B<ucg> describes it as: "Ignore case if PATTERN is all lowercase
(default: enabled)."

B<less> has the B<-i>/B<--ignore-case> option with the same function: "Causes
searches to ignore case; that is, uppercase and lowercase are considered
identical. This option is ignored if any uppercase letters appear in the search
pattern; in other words, if a pattern contains uppercase letters, then that
search does not ignore case."

Maybe add b<-s>/B<--smart-case> and b<-S>/B<--no-smart-case>. This option
should override (and be overridden by) B<--ignore-case> and
B<--no-ignore-case>.

=head2 Record set matching

There should be a way to match only entries in a specified record set. Maybe
prefix B<%rec:…>?

=head2 Number matching

Use C<[…]> to match numbers. The brackets themselves will match a number in the
text (a regex like C<< [+-]?(\d*\.)?\d+ >>, though that doesn't cover numbers
in scientific notation). After matching the mathematical expression inside the
brackets will be applied as well, so that an empty bracket C<[]> matches any
number; C<[E<lt>100]> matches any number below 100; C<[1990..2020]> will match
a number between 1990 and 2020 (inclusive), and C<[=42]> matches the number 42.

=head2 Date matching

How to solve date matching? I would like something similar to the above number
matching, but that allows for dates. (Internally translating stuff to epoch
time and comparing it that way.) Ideally the date comparison should extract and
parse date in the locale specified for the field (and be able to extract all
kinds of date formats, from 'December 1, 2020' to '2020-12-01').

=head2 Option to user pager's hiliting

Add option to, instead of highlighting the output, use pager options for the
highlighting. When using B<less> as a pager, for example, this would involve
invoking it with the B<--use-backslash> and B<+/>I<REGEX> options.

This would have the drawback that overlapping searches would not be marked, but
the benefit that the user would be able to easily navigate back and forth
between the matches inside the pager.

Maybe B<delta> uses the option B<--navigate> to: "Activate diff navigation. Use
'n' to jump forwards and 'N' to jump backwards."

=head2 Automatic linebreaking

There should maybe be an option to produce automatic linebreaks in fields? How
about fields containing explicit newlines? (Like an address, or poetry?)

=head2 Atomic file updates

Currently data is always output to standard output, regardless of whether it
was read from standard input, or from file specified on the command line. In
the future, input on standard input will result in output to standard output,
while files given on the command line will be (atomically) modified when
inserting or deleting fields/records. A tempfile will be written next to the
input file (for example, with the name 'I<FILE>B<.tmp>'). Then, if the
modification is successful the file will be is renamed to replace the old file.

=head2 Inserting new records

When I<FIELD>B<=>I<VALUE> pairs arguments are given, but no I<QUERY> is present
on the command line, the data should be inserted as a new record in the
database.

=head2 Inserting fields into existing records

When I<FIELD>B<=>I<VALUE> pairs arguments are given, and a I<QUERY> is present
on the command line, the data should be inserted into the first(?) matching as
record.

=head2 Record and field sorting

Sorting, being a slow operation, should never be performed on the whole
dictionary unless explicitly requested. (Using a B<--sort> option, perhaps?)
However, when inserting records or fields, the sort order should be respected,
and the new record/field should be inserted late as possible in the record set
or record.

B<Record sort:> In B<recutils> the B<%sort> option is used to define how
records are sorted relative to each other in a record set. For example,
B<recutils> uses B<S<%sort: author year>> to specify should be sorted primarily
by the content of the B<author> field, and secondarily by B<year>.

B<Field sort:> B<recutils> has no way of sorting fields within a record. So
will have to be invented here. Sorting should be stable, so that if there are
interleaved fields of different names, the internal order between fields of the
same name should be retained (but the different field names should no longer be
interleaved) after sorting.

=head2 Argument to clean up query

It can sometimes be hard to know how exactly B<zdb> will interpret your query.
Using this argument should show a cleaned up version of QUERY (suppressing
search). -- Should this also simplify Boolean logic? Or just show what the
query looks like after the shell has stripped its quoting? Both?

=head2 Field types and field verification

B<recutils> uses B<%type> and B<%typedef> for this purpose. Also the fields
B<%mandatory>, B<%allowed>, B<%prohibit>, B<%unique> and B<%constraint>. In
normal operation B<zdb> should give an error if user tries to add (or remove)
records or fields that break what's allowed. A B<--force> option should allow
one to make breaking changes. But verification of whole database might be too
slow to perform for each modification. (Maybe add B<--verify> option or
similar for checking the whole database?)

=head2 Suppression of length output

It would be convenient to be able to suppress lengthy output and/or disable
pager for short output (shorter than a screenful?).

=head2 Show manpage using B<$MANPAGER>

The B<--manual> option should use the B<$MANPAGER> environment variable to
determine how do display its manpage. Currently B<man -l -> is used to display
the manpage, but to allow for B<$MANPAGER> the manpage should be written to
tempfile and the manpager should be invoked as C<$MANPAGE FILE> (where I<FILE>
is a path beginning with '.' or '/').

=head2 Add record sets B<%rec> (and B<%doc>)

Implement B<recutils> 'record set' field B<%rec>. Record set name should
probably use the same limitations (and recommendations) as B<recutils> do (see
'Naming Record Types' in the B<recutils> manual).

=head2 No QUERY = Show database status

Giving an input file, but no I<QUERY> or I<FIELD>B<=>I<VALUE> pairs should give
a summary of the input file. Summary should include B<%rec> and B<%doc> fields
for each record set, and there should also be a summary of the fields usage
used for each set. For example we could see something like the following to
indicate that the field 'tlh' occurs once in 3033 records, while the field
'cite' occurs zero times in 2627 records, once in 320 records etc.

    %rec	words
    %doc	Klingonska Akademien's Klingon Dictionary
    tlh		1 -- 1:3033
    ...
    cite	0..5,7 -- 0:2627 1:320 2:58 3:18 4:4 5:4 7:3
    ...

Should also have a look at what the B<recinf> command outputs for additional
inspiration.

Also update usage to show that QUERY argument is optional! (Meaning that we
also only need one usage line instead of two.)

    zdb [OPTION]... [--] [QUERY] [FIELD=VALUE]... [FILE]

=head2 File locking

There should be some protection to avoid having multiple instances of B<zdb>
trying to modify the same file at the same time.

=head2 Highlight color config

User should be able to choose highlight color. (Should we maybe take colors
from B<$GREP_COLORS> environment variable? And make it possible to override
with our own B<ZDBCOLORS>?)

=head2 Undo

As a database is updated, patches should be generated and saved into a
directory next to the database. (Similar to how tempfiles are stored.) So,
maybe create a directory 'B<.>I<FILE>B<.undo>' (or 'B<.>I<FILE>B<.diff>') and
then, inside that directory create patches called
I<YYYYMMDDB<_>HHMMSS>B<.diff>. This way, any of the patches can be reapplied to
undo that change.---Or, possibly, diffs could instead be added to a B<.zip>
file (or other archive).

=head2 Compression

Using some kinda compression would be nice. The output should be ASCII safe,
and use z85 encoding (this is great because it avoids characters like B<">,
B<'> etc which makes it (relatively) easy to include in JSON without having to
escape stuff).

The Debian package B<coreutils> come with B<basenc> which can be used for z85
encoding. (Encode with C<basenc --z85>, decode with C<basenc --z85 -d>.)

=over 12

=item Compress

C<< | xz -c | basenc  --z85 >>


=item Decompress:

C<< | basenc --z85 -d | xz -d >>

=back

The file should be provided with a magic number which specifies both the,
compression, encoding (and possible encryption) as well as the fact that it is
a B<zbd> file. Ideally this should be in the form of a shebang line (so that
the file becomes directly 'executable' by B<zdb>). Maybe implement an option
input/output filtering different stages, maybe something like
B<--format=ed25519:xz:z85> or B<--encoding=ed25519,xz,z85> (the order would
automatically reverse on (the order would automatically reverse on
read/decode).

=head2 Encryption

(Pipe input/output through external secure tool) (also, how make THESE diffs
secure -- encrypted archive of some kind?).

The command line tool B<age> (in Debian package of same name) should be useful
here. The following commands allow input on standard input, and output on
standard output making them ideal to feed a database through them.

=over 9

=item Encrypt:

C<< age --armor --recipients-file=SSH_PUBKEY >>

=item Decrypt:

C<< age --decrypt --identity=SSH_KEYFILE >>

=back

However, B<age> does not support B<ssh-agent>, which would be very cool to use
for password caching, and it would be very cool to use this so that the
password doesn't have to be typed over and over again for every invocation of
B<zdb>.

Also, the B<age> ASCII armored format does not allow for leading and trailing
extra data, so a shebang line would have to be inserted/filtered out by B<zdb>
itself (which also makes the file less usable/recoverable for use outside with
other tools than B<zdb>).

Additionally, it'd be kinda nice to compress the datastream before encrypting
it. The compression schema should be specifiable when writing the file, chosen
automatically on reading (and rewriting, unless overridden by option).

=head2 Add date fields

Date fields should allow for the kind of date available in B<recutils>, but
also allow for simple YYYY only, or YYYY-MM etc. (Like 'date --iso=...' but
also for 'month' and 'year', and also the ones supported by date: 'date',
'hour', 'minute', 'second', 'ns')

=head2 Deleting records & fields

Add options for deleting records and fields. For example, add a
B<--delete-record> option which deletes all records matched by QUERY, and a
B<--delete-field> which deletes all fields matched by query (though the option
names should probably be shorter). Or maybe use some other scheme? (Like using
I<FIELD>B<=>I<VALUE> pairs with empty value to remove a field---though that
might be better reserved for setting a field, but leaving it empty.)

=head2 YAML support for database

Each record would be what YAML calls a 'document' (separated by C<---> on a
line of its own). This also requires support for more complicated data
structures (necessitating hierarchical field names). YAML also have alias
support, and a string like C<false> will, if unquoted, be interpreted
differently depending on schema. So schemas need to be in place for this to be
implementable (see https://spacelift.io/blog/yaml).

=head2 Boolean operator aliases

For maximum sloppiness, maybe implement all of the most common ways of writing
the Boolean operators? This would be a full table:

    ┌─────────────────────────────────┐
    │   Boolean operators             │  From the most tightly binding, to the
    ├────────┬─────┬──────────────────┤  least binding.
    │ NOT    │  !  │  -  (minus)      │
    ├────────┼─────┼──────────────────┤
    │ AND    │  &  │  ␣  (space)      │
    ├────────┼─────┼──────────────────┤
    │ OR     │  |  │  ,  (comma)      │
    ├────────┼─────┼──────────────────┤
    │ XOR    │  ^  │  ;  (semicolon?) │<-- Priority? (Also, maybe use '/'?)
    ├────────┼─────┴──────────────────┤
    │ GROUP¹ │ (…) (parens)           │ ¹ Missing parentheses are automatically
    └────────┴────────────────────────┘   added at the start or end of a query.

Currently only minus, space, comma and parentheses are implemented. The
additional version would just be for convenience for people who are used to
some other name for the operator. For the spelled out versions of the operators
capital letters are required (lower case should always match the words
literally), and (of course) it'll only work when they're unquoted.

Also the more C-like versions C<< && >> and C<< || >> will have exactly same
effect as their non-doubled counterparts---the parser simply sees an empty
search expression between them (which counts as nothing) and the result is the
same as the non-doubled version.

For C<< ! >>, however, this is not true, and doubling that negates the negation.

=cut

#[eof]
